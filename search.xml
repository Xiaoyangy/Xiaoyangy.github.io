<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>表驱动法</title>
    <url>/2020/03/10/%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/</url>
    <content><![CDATA[<p>当程序中 if else 或者 switch case 过多时可以使用表驱动法</p>
<p>如下,将16进制转成8进制为例,可以先将16进制的每一位数字都以字符形式存入一个表内,在遍历输入时直接就可转换为2进制并储存起来</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str_table[<span class="number">256</span>]=&#123;</span><br><span class="line"><span class="string">"0000"</span>,<span class="string">"0001"</span>,<span class="string">"0010"</span>,<span class="string">"0011"</span>,</span><br><span class="line"><span class="string">"0100"</span>,<span class="string">"0101"</span>,<span class="string">"0110"</span>,<span class="string">"0111"</span>,</span><br><span class="line"><span class="string">"1000"</span>,<span class="string">"1001"</span>,<span class="string">"1010"</span>,<span class="string">"1011"</span>,</span><br><span class="line"><span class="string">"1100"</span>,<span class="string">"1101"</span>,<span class="string">"1110"</span>,<span class="string">"1111"</span>&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key      value</span></span><br><span class="line"><span class="comment">0  ASCII - ASCII '0'-'0'       0000</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">int main()&#123;</span><br><span class="line">    //<span class="number">16</span>进制<span class="number">8</span>进制</span><br><span class="line">    //</span><br><span class="line">    str_table[<span class="string">'0'</span>]=<span class="string">"0000"</span>;</span><br><span class="line">    str_table[<span class="string">'1'</span>]=<span class="string">"0001"</span>;</span><br><span class="line">    str_table[<span class="string">'2'</span>]=<span class="string">"0010"</span>;</span><br><span class="line">    str_table[<span class="string">'3'</span>]=<span class="string">"0011"</span>;</span><br><span class="line">    str_table[<span class="string">'4'</span>]=<span class="string">"0100"</span>;</span><br><span class="line">    str_table[<span class="string">'5'</span>]=<span class="string">"0101"</span>;</span><br><span class="line">    str_table[<span class="string">'6'</span>]=<span class="string">"0110"</span>;</span><br><span class="line">    str_table[<span class="string">'7'</span>]=<span class="string">"0111"</span>;</span><br><span class="line">    str_table[<span class="string">'8'</span>]=<span class="string">"1000"</span>;</span><br><span class="line">    str_table[<span class="string">'9'</span>]=<span class="string">"1001"</span>;</span><br><span class="line">    str_table[<span class="string">'a'</span>]=<span class="string">"1010"</span>;</span><br><span class="line">    str_table[<span class="string">'A'</span>]=<span class="string">"1010"</span>;</span><br><span class="line">    str_table[<span class="string">'b'</span>]=<span class="string">"1011"</span>;</span><br><span class="line">    str_table[<span class="string">'B'</span>]=<span class="string">"1011"</span>;</span><br><span class="line">    str_table[<span class="string">'c'</span>]=<span class="string">"1100"</span>;</span><br><span class="line">    str_table[<span class="string">'C'</span>]=<span class="string">"1100"</span>;</span><br><span class="line">    str_table[<span class="string">'D'</span>]=<span class="string">"1101"</span>;</span><br><span class="line">    str_table[<span class="string">'d'</span>]=<span class="string">"1101"</span>;</span><br><span class="line">    str_table[<span class="string">'E'</span>]=<span class="string">"1110"</span>;</span><br><span class="line">    str_table[<span class="string">'e'</span>]=<span class="string">"1110"</span>;</span><br><span class="line">    str_table[<span class="string">'F'</span>]=<span class="string">"1111"</span>;</span><br><span class="line">    str_table[<span class="string">'f'</span>]=<span class="string">"1111"</span>;</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;cin&gt;&gt;str;</span><br><span class="line">    string eight_str=<span class="string">""</span>;</span><br><span class="line">    for(int i=<span class="number">0</span>;i&lt;str.size();i++)&#123;</span><br><span class="line">        eight_str+=str_table[str[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    while(eight_str.size()<span class="comment">%3!=0)&#123;</span></span><br><span class="line">        eight_str=<span class="string">"0"</span>+eight_str;</span><br><span class="line">    &#125;</span><br><span class="line"> //   cout&lt;&lt;eight_str;</span><br><span class="line">    if((eight_str[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">4</span>+(eight_str[<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">2</span>+(eight_str[<span class="number">2</span>]-<span class="string">'0'</span>)!=<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;(eight_str[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">4</span>+(eight_str[<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">2</span>+(eight_str[<span class="number">2</span>]-<span class="string">'0'</span>);</span><br><span class="line">    for(int i=<span class="number">3</span>;i&lt;eight_str.size();i+=<span class="number">3</span>)&#123;</span><br><span class="line">        cout&lt;&lt;((eight_str[i]-<span class="string">'0'</span>)*pow(<span class="number">2</span>,<span class="number">2</span>)+(eight_str[i+<span class="number">1</span>]-<span class="string">'0'</span>)*pow(<span class="number">2</span>,<span class="number">1</span>)+(eight_str[i+<span class="number">2</span>]-<span class="string">'0'</span>*pow(<span class="number">2</span>,<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis参数异常</title>
    <url>/2020/03/08/mybatis%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>mybatis 参数格式异常-- Error querying database. Cause: java.lang.NumberFormatException: For input string</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis中 <span class="tag">&lt;<span class="name">if</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span>标签中进行判断时，如果传入的时字符格式和数字进行判断需要将数字进行转译，否则默认是数字和数字进行比较，这是就会出现参数格式异常</span><br><span class="line">如<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"department != 0 and department != null"</span> &gt;</span> 中不对0进行转译就会出现这个错误</span><br><span class="line">可以将0用“”引起来，外面的“”改编成‘’或者将0变成‘0’.toString()，如下所示：（将0直接以‘’处理就会变成String格式和char格式进行比较，也会出现同类错误）</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">‘department</span> != <span class="string">“0”</span> <span class="attr">and</span> <span class="attr">department</span> != <span class="string">null’</span> &gt;</span></span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"department != ‘0’.toString() and department != null"</span> &gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>犯过的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>Unknowncharacter解决方法</title>
    <url>/2020/03/08/character%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Unknown initial character set index ‘255’ received from server. Initial client character set can be forced via the ‘characterEncoding’ property.</p>
<p>从错误的提示信息中发现字符集设置出现问题</p>
<p>修改为以下即可</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">jdbc.url= <span class="string">jdbc:</span><span class="string">mysql:</span><span class="comment">//localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>日志代码</title>
    <url>/2020/03/08/%E6%97%A5%E5%BF%97%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>位置: next/layout/_macro/sidebar.swig/</p>
<p>47行左右</p>
<p>已删除</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> config.archive_dir != '/' and site.posts.length &gt; 0 %&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-state-item site-state-posts"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.menu.archives %&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.archives).split('||')[0] | trim &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(config.archive_dir) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-count"</span>&gt;</span></span><span class="template-variable">&#123;&#123; site.posts.length &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-name"</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('state.posts') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Spring的事务性</title>
    <url>/2020/03/07/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%80%A7/</url>
    <content><![CDATA[<h2 id="1-初步理解"><a class="markdownIt-Anchor" href="#1-初步理解"></a> 1 初步理解</h2>
<p>事务有四个特性 ACID,与数据库一致</p>
<blockquote>
<ul>
<li>原子性(Atomicity) : 事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="2-核心接口"><a class="markdownIt-Anchor" href="#2-核心接口"></a> 2 核心接口</h2>
<p>Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务，下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略。<br>
Spring事务管理涉及的接口的联系如下：</p>
<p><img src="/images/jie.jpg" alt></p>
<h4 id="21-事务管理器"><a class="markdownIt-Anchor" href="#21-事务管理器"></a> 2.1 事务管理器</h4>
<p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。<br>
Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </span><br><span class="line">    <span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">    <span class="comment">// 提交</span></span><br><span class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="comment">// 回滚</span></span><br><span class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<h5 id="211-jdbc事务"><a class="markdownIt-Anchor" href="#211-jdbc事务"></a> 2.1.1 JDBC事务</h5>
<p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h5 id="212-hibernate事务"><a class="markdownIt-Anchor" href="#212-hibernate事务"></a> 2.1.2 Hibernate事务</h5>
<p>如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：</bean></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h5 id="213-java持久化api事务jpa"><a class="markdownIt-Anchor" href="#213-java持久化api事务jpa"></a> 2.1.3 Java持久化API事务(JPA)</h5>
<p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p>
<h5 id="214-java原生api事务"><a class="markdownIt-Anchor" href="#214-java原生api事务"></a> 2.1.4 Java原生API事务</h5>
<p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManagerName"</span> <span class="attr">value</span>=<span class="string">"java:/TransactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p>
<h4 id="22-基本事务属性的定义"><a class="markdownIt-Anchor" href="#22-基本事务属性的定义"></a> 2.2 基本事务属性的定义</h4>
<p>上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。<br>
那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面，如图所示：</p>
<p><img src="/images/shiwushuxing.jpg" alt></p>
<p>而TransactionDefinition接口内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现TransactionDefinition正好用来定义事务属性，下面详细介绍一下各个事务属性。</p>
<h5 id="221-传播行为"><a class="markdownIt-Anchor" href="#221-传播行为"></a> 2.2.1 传播行为</h5>
<p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED</td>
<td>表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRED_NEW</td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td>
</tr>
</tbody>
</table>
<p><em>注：以下具体讲解传播行为的内容参考自<a href="http://www.open-open.com/lib/view/open1350865116821.html">Spring事务机制详解</a></em><br>
（1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodB&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。</p>
<p>单独调用methodB方法：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">main&#123; </span><br><span class="line">    metodB()<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Main&#123; </span><br><span class="line">    Connection con=null; </span><br><span class="line">    <span class="keyword">try</span>&#123; </span><br><span class="line">        con = get<span class="constructor">Connection()</span>; </span><br><span class="line">        con.set<span class="constructor">AutoCommit(<span class="params">false</span>)</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法调用</span></span><br><span class="line">        <span class="keyword">method</span><span class="constructor">B()</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        con.commit<span class="literal">()</span>; </span><br><span class="line">    &#125; <span class="constructor">Catch(RuntimeException <span class="params">ex</span>)</span> &#123; </span><br><span class="line">        <span class="comment">//回滚事务</span></span><br><span class="line">        con.rollback<span class="literal">()</span>;   </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        close<span class="constructor">Con()</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。<br>
单独调用MethodA时，在MethodA内又会调用MethodB.</p>
<p>执行效果相当于：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">main&#123; </span><br><span class="line">   <span class="built_in"> Connection </span>con = <span class="literal">null</span>; </span><br><span class="line">    try&#123; </span><br><span class="line">        con = getConnection(); </span><br><span class="line">        methodA(); </span><br><span class="line">        con.commit(); </span><br><span class="line">    &#125; catch(RuntimeException ex) &#123; </span><br><span class="line">        con.rollback(); </span><br><span class="line">    &#125; finally &#123;    </span><br><span class="line">        closeCon(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用MethodA时，环境中没有事务，所以开启一个新的事务.当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。</p>
<p>（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="keyword">method</span><span class="constructor">A()</span>&#123;</span><br><span class="line">  <span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_SUPPORTS</span></span><br><span class="line"><span class="keyword">method</span><span class="constructor">B()</span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</p>
<p>（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="keyword">method</span><span class="constructor">A()</span>&#123;</span><br><span class="line">    <span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_MANDATORY</span></span><br><span class="line">    <span class="keyword">method</span><span class="constructor">B()</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p>
<p>（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="keyword">method</span><span class="constructor">A()</span>&#123;</span><br><span class="line">    <span class="keyword">do</span><span class="constructor">SomeThingA()</span>;</span><br><span class="line">    <span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">    <span class="keyword">do</span><span class="constructor">SomeThingB()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRES_NEW</span></span><br><span class="line"><span class="keyword">method</span><span class="constructor">B()</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用A方法：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">main</span>()&#123;</span></span><br><span class="line"><span class="function">    <span class="title">methodA</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">main<span class="literal">()</span>&#123;</span><br><span class="line">    TransactionManager tm = null;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获得一个JTA事务管理器</span></span><br><span class="line">        tm = get<span class="constructor">TransactionManager()</span>;</span><br><span class="line">        tm.<span class="keyword">begin</span><span class="literal">()</span>;<span class="comment">//开启一个新的事务</span></span><br><span class="line">        Transaction ts1 = tm.get<span class="constructor">Transaction()</span>;</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">SomeThing()</span>;</span><br><span class="line">        tm.suspend<span class="literal">()</span>;<span class="comment">//挂起当前事务</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            tm.<span class="keyword">begin</span><span class="literal">()</span>;<span class="comment">//重新开启第二个事务</span></span><br><span class="line">            Transaction ts2 = tm.get<span class="constructor">Transaction()</span>;</span><br><span class="line">            <span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">            ts2.commit<span class="literal">()</span>;<span class="comment">//提交第二个事务</span></span><br><span class="line">        &#125; <span class="constructor">Catch(RunTimeException <span class="params">ex</span>)</span> &#123;</span><br><span class="line">            ts2.rollback<span class="literal">()</span>;<span class="comment">//回滚第二个事务</span></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//methodB执行完后，恢复第一个事务</span></span><br><span class="line">        tm.resume(ts1);</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">SomeThingB()</span>;</span><br><span class="line">        ts1.commit<span class="literal">()</span>;<span class="comment">//提交第一个事务</span></span><br><span class="line">    &#125; catch(RunTimeException ex) &#123;</span><br><span class="line">        ts1.rollback<span class="literal">()</span>;<span class="comment">//回滚第一个事务</span></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。</p>
<p>（5）PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。（代码示例同上，可同理推出）</p>
<p>（6）PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
<p>（7）PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_NESTED</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">main</span>()&#123;</span></span><br><span class="line"><span class="function">    <span class="variable">Connection</span> <span class="variable">con</span> = <span class="variable"><span class="literal">null</span></span>;</span></span><br><span class="line"><span class="function">    <span class="variable">Savepoint</span> <span class="variable">savepoint</span> = <span class="variable"><span class="literal">null</span></span>;</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">try</span></span>&#123;</span></span><br><span class="line"><span class="function">        <span class="variable">con</span> = <span class="title">getConnection</span>();</span></span><br><span class="line"><span class="function">        <span class="variable">con.setAutoCommit</span>(<span class="variable"><span class="literal">false</span></span>);</span></span><br><span class="line"><span class="function">        <span class="title">doSomeThingA</span>();</span></span><br><span class="line"><span class="function">        <span class="variable">savepoint</span> = <span class="variable">con2.setSavepoint</span>();</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">try</span></span>&#123;</span></span><br><span class="line"><span class="function">            <span class="title">methodB</span>();</span></span><br><span class="line"><span class="function">        &#125; <span class="title">catch</span>(<span class="variable">RuntimeException</span> <span class="variable">ex</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="variable">con.rollback</span>(<span class="variable">savepoint</span>);</span></span><br><span class="line"><span class="function">        &#125; <span class="variable"><span class="keyword">finally</span></span> &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">//释放资源</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">doSomeThingB</span>();</span></span><br><span class="line"><span class="function">        <span class="variable">con.commit</span>();</span></span><br><span class="line"><span class="function">    &#125; <span class="title">catch</span>(<span class="variable">RuntimeException</span> <span class="variable">ex</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="variable">con.rollback</span>();</span></span><br><span class="line"><span class="function">    &#125; <span class="variable"><span class="keyword">finally</span></span> &#123;</span></span><br><span class="line"><span class="function">        <span class="comment">//释放资源</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。</p>
<p>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。</p>
<p>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。</p>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。</p>
<p>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.</p>
<p>PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>
<h5 id="222-隔离级别"><a class="markdownIt-Anchor" href="#222-隔离级别"></a> 2.2.2 隔离级别</h5>
<p>事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。<br>
（1）并发事务引起的问题<br>
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。</p>
<blockquote>
<ul>
<li>脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li>
<li>不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li>
<li>幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li>
</ul>
</blockquote>
<p><strong>不可重复读与幻读的区别</strong></p>
<p>不可重复读的重点是修改:<br>
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了<br>
例如：在事务1中，Mary 读取了自己的工资为1000,操作并没有完成</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">con1</span> = getConnection()<span class="comment">;  </span></span><br><span class="line">    select salary from employee empId =<span class="string">"Mary"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">con2</span> = getConnection()<span class="comment">;  </span></span><br><span class="line">update employee set salary = <span class="number">2000</span><span class="comment">;  </span></span><br><span class="line">con2.commit()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//con1  </span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> employee empId =<span class="string">"Mary"</span>;</span><br></pre></td></tr></table></figure>
<p>在一个事务中前后两次读取的结果并不一致，导致了不可重复读。</p>
<p>幻读的重点在于新增或者删除：<br>
同样的条件, 第1次和第2次读出来的记录数不一样<br>
例如：目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">con1 = getConnection();  </span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> salary =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>共读取10条记录</p>
<p>这时另一个事务向employee表插入了一条员工记录，工资也为1000</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">con2 = getConnection();  </span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> employee(empId,salary) <span class="keyword">values</span>(<span class="string">"Lili"</span>,<span class="number">1000</span>);  </span><br><span class="line">con2.commit();</span><br></pre></td></tr></table></figure>
<p>事务1再次读取所有工资为1000的员工</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//con1  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> salary =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>共读取到了11条记录，这就产生了幻像读。</p>
<p>从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。<br>
对于前者, 只需要锁住满足条件的记录。<br>
对于后者, 要锁住满足条件及其相近的记录。</p>
<p>（2）隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
</tr>
</tbody>
</table>
<h5 id="223-只读"><a class="markdownIt-Anchor" href="#223-只读"></a> 2.2.3 只读</h5>
<p>事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p>
<h5 id="224-事务超时"><a class="markdownIt-Anchor" href="#224-事务超时"></a> 2.2.4 事务超时</h5>
<p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h5 id="225-回滚规则"><a class="markdownIt-Anchor" href="#225-回滚规则"></a> 2.2.5 回滚规则</h5>
<p>事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）<br>
但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<h4 id="23-事务状态"><a class="markdownIt-Anchor" href="#23-事务状态"></a> 2.3 事务状态</h4>
<p>上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。</p>
<h2 id="3-编程式事务"><a class="markdownIt-Anchor" href="#3-编程式事务"></a> 3 编程式事务</h2>
<h4 id="31-编程式和声明式事务的区别"><a class="markdownIt-Anchor" href="#31-编程式和声明式事务的区别"></a> 3.1 编程式和声明式事务的区别</h4>
<p>Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。<br>
简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h4 id="32-如何实现编程式事务"><a class="markdownIt-Anchor" href="#32-如何实现编程式事务"></a> 3.2 如何实现编程式事务?</h4>
<p>Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager。</p>
<h5 id="321-使用transactiontemplate"><a class="markdownIt-Anchor" href="#321-使用transactiontemplate"></a> 3.2.1 使用TransactionTemplate</h5>
<p>采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">TransactionTemplate tt = <span class="keyword">new</span> <span class="constructor">TransactionTemplate()</span>; <span class="comment">// 新建一个TransactionTemplate</span></span><br><span class="line">Object result = tt.execute(</span><br><span class="line">    <span class="keyword">new</span> <span class="constructor">TransactionCallback()</span>&#123;  </span><br><span class="line">        public Object <span class="keyword">do</span><span class="constructor">Transaction(TransactionStatus <span class="params">status</span>)</span>&#123;  </span><br><span class="line">            update<span class="constructor">Operation()</span>;  </span><br><span class="line">            return result<span class="constructor">OfUpdateOperation()</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); <span class="comment">// 执行execute方法进行事务管理</span></span><br></pre></td></tr></table></figure>
<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值。</p>
<h5 id="322-使用platformtransactionmanager"><a class="markdownIt-Anchor" href="#322-使用platformtransactionmanager"></a> 3.2.2  使用PlatformTransactionManager</h5>
<p>示例代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DataSourceTransactionManager dataSourceTransactionManager = <span class="keyword">new</span> <span class="constructor">DataSourceTransactionManager()</span>; <span class="comment">//定义一个某个框架平台的TransactionManager，如JDBC、Hibernate</span></span><br><span class="line">dataSourceTransactionManager.set<span class="constructor">DataSource(<span class="params">this</span>.<span class="params">getJdbcTemplate</span>()</span>.get<span class="constructor">DataSource()</span>); <span class="comment">// 设置数据源</span></span><br><span class="line">DefaultTransactionDefinition transDef = <span class="keyword">new</span> <span class="constructor">DefaultTransactionDefinition()</span>; <span class="comment">// 定义事务属性</span></span><br><span class="line">transDef.set<span class="constructor">PropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED)</span>; <span class="comment">// 设置传播行为属性</span></span><br><span class="line">TransactionStatus status = dataSourceTransactionManager.get<span class="constructor">Transaction(<span class="params">transDef</span>)</span>; <span class="comment">// 获得事务状态</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">    dataSourceTransactionManager.commit(status);<span class="comment">// 提交</span></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    dataSourceTransactionManager.rollback(status);<span class="comment">// 回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-声明式事务"><a class="markdownIt-Anchor" href="#4-声明式事务"></a> 4 声明式事务</h2>
<h4 id="41-配置方式"><a class="markdownIt-Anchor" href="#41-配置方式"></a> 4.1 配置方式</h4>
<p>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：</p>
<p>（1）每个Bean都有一个代理</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:hibernate.cfg.xml"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configurationClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.AnnotationConfiguration"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DAO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoTarget"</span> <span class="attr">class</span>=<span class="string">"com.bluesky.spring.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span> </span><br><span class="line">           <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> /&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDaoTarget"</span> /&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.bluesky.spring.dao.GeneratorDao"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置事务属性 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）所有Bean共享一个代理基类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:hibernate.cfg.xml"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configurationClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.AnnotationConfiguration"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionBase"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> /&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 配置事务属性 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DAO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoTarget"</span> <span class="attr">class</span>=<span class="string">"com.bluesky.spring.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">parent</span>=<span class="string">"transactionBase"</span> &gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDaoTarget"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）使用拦截器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:hibernate.cfg.xml"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configurationClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.AnnotationConfiguration"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionInterceptor"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> /&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 配置事务属性 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>*Dao<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>transactionInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DAO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.bluesky.spring.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（4）使用tx标签配置的拦截器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bluesky"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:hibernate.cfg.xml"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configurationClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.AnnotationConfiguration"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"interceptorPointCuts"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">"execution(* com.bluesky.spring.dao.*.*(..))"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">pointcut-ref</span>=<span class="string">"interceptorPointCuts"</span> /&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（5）全注解</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bluesky"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:hibernate.cfg.xml"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configurationClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.AnnotationConfiguration"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时在DAO上需加上@Transactional注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bluesky.spring.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate3.support.HibernateDaoSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bluesky.spring.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">HibernateDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSession().createQuery(<span class="string">"from User"</span>).list();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="42-一个声明式事务的实例"><a class="markdownIt-Anchor" href="#42-一个声明式事务的实例"></a> 4.2 一个声明式事务的实例</h4>
<p><strong>首先是数据库表</strong><br>
book(isbn, book_name, price)<br>
account(username, balance)<br>
book_stock(isbn, stock)</p>
<p><strong>然后是XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext-db.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">        <span class="attr">base-package</span>=<span class="string">"com.springinaction.transaction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用的类</strong><br>
BookShopDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookShopDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据书号获取书的单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBookPriceByIsbn</span><span class="params">(String isbn)</span></span>;</span><br><span class="line">    <span class="comment">// 更新书的库存，使书号对应的库存-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBookStock</span><span class="params">(String isbn)</span></span>;</span><br><span class="line">    <span class="comment">// 更新用户的账户余额：account的balance-price</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserAccount</span><span class="params">(String username, <span class="keyword">int</span> price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookShopDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"bookShopDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShopDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookShopDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate JdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBookPriceByIsbn</span><span class="params">(String isbn)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT price FROM book WHERE isbn = ?"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JdbcTemplate.queryForObject(sql, Integer<span class="class">.<span class="keyword">class</span>, <span class="title">isbn</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBookStock</span><span class="params">(String isbn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查书的库存是否足够，若不够，则抛出异常</span></span><br><span class="line">        String sql2 = <span class="string">"SELECT stock FROM book_stock WHERE isbn = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> stock = JdbcTemplate.queryForObject(sql2, Integer<span class="class">.<span class="keyword">class</span>, <span class="title">isbn</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (stock == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BookStockException(<span class="string">"库存不足！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = <span class="string">"UPDATE book_stock SET stock = stock - 1 WHERE isbn = ?"</span>;</span><br><span class="line">        JdbcTemplate.update(sql, isbn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserAccount</span><span class="params">(String username, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查余额是否不足，若不足，则抛出异常</span></span><br><span class="line">        String sql2 = <span class="string">"SELECT balance FROM account WHERE username = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> balance = JdbcTemplate.queryForObject(sql2, Integer<span class="class">.<span class="keyword">class</span>, <span class="title">username</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; price) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserAccountException(<span class="string">"余额不足！"</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        String sql = <span class="string">"UPDATE account SET balance = balance - ? WHERE username = ?"</span>;</span><br><span class="line">        JdbcTemplate.update(sql, price, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookShopService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookShopService</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String username, String isbn)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"bookShopService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShopServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookShopService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookShopDao bookShopDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.添加事务注解</span></span><br><span class="line"><span class="comment">     * 使用propagation 指定事务的传播行为，即当前的事务方法被另外一个事务方法调用时如何使用事务。</span></span><br><span class="line"><span class="comment">     * 默认取值为REQUIRED，即使用调用方法的事务</span></span><br><span class="line"><span class="comment">     * REQUIRES_NEW：使用自己的事务，调用的事务方法的事务被挂起。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2.使用isolation 指定事务的隔离级别，最常用的取值为READ_COMMITTED</span></span><br><span class="line"><span class="comment">     * 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。通常情况下，默认值即可。</span></span><br><span class="line"><span class="comment">     * 4.使用readOnly 指定事务是否为只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取数据库值得方法，应设置readOnly=true</span></span><br><span class="line"><span class="comment">     * 5.使用timeOut 指定强制回滚之前事务可以占用的时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW,</span><br><span class="line">            isolation=Isolation.READ_COMMITTED,</span><br><span class="line">            noRollbackFor=&#123;UserAccountException<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">            <span class="title">readOnly</span></span>=<span class="keyword">true</span>, timeout=<span class="number">3</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String username, String isbn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取书的单价</span></span><br><span class="line">        <span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">        <span class="comment">//2.更新书的库存</span></span><br><span class="line">        bookShopDao.updateBookStock(isbn);</span><br><span class="line">        <span class="comment">//3.更新用户余额</span></span><br><span class="line">        bookShopDao.updateUserAccount(username, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cashier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkout</span><span class="params">(String username, List&lt;String&gt;isbns)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CashierImpl：CashierImpl.checkout和bookShopService.purchase联合测试了事务的传播行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"cashier"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashierImpl</span> <span class="keyword">implements</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookShopService bookShopService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkout</span><span class="params">(String username, List&lt;String&gt; isbns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String isbn : isbns) &#123;</span><br><span class="line">            bookShopService.purchase(username, isbn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookStockException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookStockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookStockException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookStockException</span><span class="params">(String arg0, Throwable arg1, <span class="keyword">boolean</span> arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> arg3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0, arg1, arg2, arg3);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookStockException</span><span class="params">(String arg0, Throwable arg1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0, arg1);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookStockException</span><span class="params">(String arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookStockException</span><span class="params">(Throwable arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserAccountException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAccountException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0, Throwable arg1, <span class="keyword">boolean</span> arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> arg3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0, arg1, arg2, arg3);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0, Throwable arg1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0, arg1);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(Throwable arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(arg0);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransitionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> BookShopDao bookShopDao = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> BookShopService bookShopService = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Cashier cashier = <span class="keyword">null</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config/transaction.xml"</span>);</span><br><span class="line">        bookShopDao = ctx.getBean(BookShopDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bookShopService = ctx.getBean(BookShopService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        cashier = ctx.getBean(Cashier<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoFindPriceByIsbn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(bookShopDao.findBookPriceByIsbn(<span class="string">"1001"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoUpdateBookStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookShopDao.updateBookStock(<span class="string">"1001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoUpdateUserAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookShopDao.updateUserAccount(<span class="string">"AA"</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bookShopService.purchase(<span class="string">"AA"</span>, <span class="string">"1001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransactionPropagation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cashier.checkout(<span class="string">"AA"</span>, Arrays.asList(<span class="string">"1001"</span>, <span class="string">"1002"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
  </entry>
  <entry>
    <title>background</title>
    <url>/2020/03/07/background/</url>
    <content><![CDATA[<p>body {<br>
background:url(<a href="https://uploadbeta.com/api/pictures/random/?key=BingEveryday">https://uploadbeta.com/api/pictures/random/?key=BingEveryday</a>	WallpaperPicture);<br>
background-repeat: no-repeat;<br>
background-attachment: fixed;<br>
background-position: center;<br>
}</p>
<p>url : 指定链接</p>
<p>repeat: 重复问题</p>
<p>attachment: 是否移动</p>
<p>position: 出现位置</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>实现queue</title>
    <url>/2020/03/05/%E5%AE%9E%E7%8E%B0queue/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2020/03/04/%E5%90%88%E5%B9%B6%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>leecode 56</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目：给出一个区间的集合，请合并所有重叠的区间。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>
<p>首先对集合进行排序，intervals.sort( )按照每个数组的首个数字排序；</p>
</li>
<li>
<p>考虑前一区间、后一区间的重叠关系：“交叉”、“覆盖”</p>
</li>
<li>
<p>使用一临时区间temp记录合并后的左右端点，合并时更新temp的右端点即可。</p>
<a id="more"></a>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ve;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    f.push_back(<span class="number">1</span>);</span><br><span class="line">    f.push_back(<span class="number">3</span>);</span><br><span class="line">    ve.push_back(f);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">    g.push_back(<span class="number">2</span>);</span><br><span class="line">    g.push_back(<span class="number">6</span>);</span><br><span class="line">    ve.push_back(g);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    h.push_back(<span class="number">8</span>);</span><br><span class="line">    h.push_back(<span class="number">10</span>);</span><br><span class="line">    ve.push_back(h);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; j;</span><br><span class="line">    j.push_back(<span class="number">15</span>);</span><br><span class="line">    j.push_back(<span class="number">18</span>);</span><br><span class="line">    ve.push_back(j);</span><br><span class="line">    sort(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">int</span> left=ve[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right=ve[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ve.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i][<span class="number">0</span>]&lt;=right)&#123;</span><br><span class="line">            right=<span class="built_in">max</span>(ve[i][<span class="number">1</span>],right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            q.push_back(left);</span><br><span class="line">            q.push_back(right);</span><br><span class="line">            v.push_back(q);</span><br><span class="line">            left=ve[i][<span class="number">0</span>];</span><br><span class="line">            right=ve[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">       s.push_back(left);</span><br><span class="line">       s.push_back(right);</span><br><span class="line">       v.push_back(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][<span class="number">0</span>]&lt;&lt;<span class="string">","</span>&lt;&lt;v[i][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案1   排序后比较.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring题目</title>
    <url>/2020/03/03/Spring%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p><strong>AOP(面向切面编程)</strong></p>
<p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
<p>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。</p>
<p>使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。</p>
<p>从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。</p>
<p>这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。</p>
<p>Spring的AOP的原理。</p>
<ol>
<li>AOP相关的概念</li>
</ol>
<p>1） <em>Aspect</em> ：切面，切入系统的一个切面。比如事务管理是一个切面，权限管理也是一个切面；</p>
<p>2） <em>Join point</em> ：连接点，也就是可以进行横向切入的位置；</p>
<p>3） <em>Advice</em> ：通知，切面在某个连接点执行的操作(分为: <em>Before advice</em> , <em>After returning advice</em> , <em>After throwing advice</em> , <em>After (finally) advice</em> , <em>Around advice</em> )；</p>
<p>4） <em>Pointcut</em> ：切点，符合切点表达式的连接点，也就是真正被切入的地方；</p>
<ol start="2">
<li>AOP 的实现原理</li>
</ol>
<p>AOP分为静态AOP和动态AOP。</p>
<p>静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。</p>
<p>动态AOP是指将切面代码进行动态织入实现的AOP。</p>
<p>Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术) 。尽管实现技术不一样，但 都是基于代理模式 ， 都是生成一个代理对象 。</p>
<a id="more"></a>
<h4 id="1-jdk动态代理"><a class="markdownIt-Anchor" href="#1-jdk动态代理"></a> 1) JDK动态代理</h4>
<p>主要使用到 InvocationHandler 接口和 Proxy.newProxyInstance() 方法。</p>
<p>JDK动态代理要求被代理实现一个接口，只有接口中的方法才能够被代理 。</p>
<p>其方法是将被代理对象注入到一个中间对象，而中间对象实现InvocationHandler接口，</p>
<p>在实现该接口时，可以在 被代理对象调用它的方法时，在调用的前后插入一些代码。</p>
<p>而 Proxy.newProxyInstance() 能够利用中间对象来生产代理对象。</p>
<p>插入的代码就是切面代码。所以使用JDK动态代理可以实现AOP。</p>
<p>我们看个例子：</p>
<p>被代理对象实现的接口，只有接口中的方法才能够被代理：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserService &#123;</span><br><span class="line">    public void addUser(User user);</span><br><span class="line">    public<span class="built_in"> User </span>getUser(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public<span class="built_in"> User </span>getUser(int id) &#123;</span><br><span class="line">       <span class="built_in"> User user </span>= new User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理中间类：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object <span class="keyword">target</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import net.aazj.pojo.User;</span><br><span class="line">public <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> <span class="constructor">UserServiceImpl()</span>;    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> <span class="constructor">ProxyUtil(<span class="params">proxyedObject</span>)</span>;</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(Thread.<span class="params">currentThread</span>()</span>.get<span class="constructor">ContextClassLoader()</span>, </span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">UserServiceImpl</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Interfaces()</span>, proxyUtils);</span><br><span class="line">        proxyObject.get<span class="constructor">User(1)</span>;</span><br><span class="line">        proxyObject.add<span class="constructor">User(<span class="params">new</span> User()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">getUser <span class="keyword">from</span> database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="builtin-name">add</span><span class="built_in"> user </span>into database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">我们看到在 UserService接口中的方法 addUser 和 getUser方法的前面插入了我们自己的代码。这就是JDK动态代理实现AOP的原理。</span><br><span class="line"></span><br><span class="line">我们看到该方式有一个要求， 被代理的对象必须实现接口，而且只有接口中的方法才能被代理 。</span><br></pre></td></tr></table></figure>
<p>2）CGLIB （code generate libary）</p>
<p>字节码生成技术实现AOP，其实就是继承被代理对象，然后Override需要被代理的方法，在覆盖该方法时，自然是可以插入我们自己的代码的。</p>
<p>因为需要Override被代理对象的方法，所以自然CGLIB技术实现AOP时，就 必须要求需要被代理的方法不能是final方法，因为final方法不能被子类覆盖 。</p>
<p>我们使用CGLIB实现上面的例子：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.aazj.aop;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.<span class="keyword">target</span>.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> enhancer.<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> <span class="type">UserServiceImpl</span>();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> <span class="type">CGProxy</span>(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> <span class="type">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">getUser <span class="keyword">from</span> database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="builtin-name">add</span><span class="built_in"> user </span>into database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">我们看到达到了同样的效果。</span><br><span class="line">它的原理是生成一个父类 enhancer.setSuperclass( this.target.getClass()) 的子类 enhancer.create() ，然后对父类的方法进行拦截enhancer.setCallback( this) . </span><br><span class="line">对父类的方法进行覆盖，所以父类方法不能是final的。</span><br></pre></td></tr></table></figure>
<p>3） 接下来我们看下spring实现AOP的相关源码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="title">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport <span class="built_in">config</span>)</span> throws AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="built_in">config</span>.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(<span class="built_in">config</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码我们可以看到：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (targetClass.is<span class="constructor">Interface()</span>) &#123;</span><br><span class="line">                return <span class="keyword">new</span> <span class="constructor">JdkDynamicAopProxy(<span class="params">config</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="keyword">new</span> <span class="constructor">ObjenesisCglibAopProxy(<span class="params">config</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果被代理对象实现了接口，那么就使用JDK的动态代理技术，反之则使用CGLIB来实现AOP，所以 Spring默认是使用JDK的动态代理技术实现AOP的 。</p>
<p>JdkDynamicAopProxy的实现其实很简单：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final <span class="keyword">class</span> JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;    </span><br><span class="line">@Override</span><br><span class="line">public Object get<span class="constructor">Proxy(ClassLoader <span class="params">classLoader</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + this.advised.get<span class="constructor">TargetSource()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;<span class="literal">[]</span> proxiedInterfaces = <span class="module-access"><span class="module"><span class="identifier">AopProxyUtils</span>.</span></span>complete<span class="constructor">ProxiedInterfaces(<span class="params">this</span>.<span class="params">advised</span>)</span>;</span><br><span class="line">    find<span class="constructor">DefinedEqualsAndHashCodeMethods(<span class="params">proxiedInterfaces</span>)</span>;</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">classLoader</span>, <span class="params">proxiedInterfaces</span>, <span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\3. Spring AOP的配置</p>
<p>Spring中AOP的配置一般有两种方法，一种是使用 <a href="aop:config">aop:config</a> 标签在xml中进行配置，一种是使用注解以及@Aspect风格的配置。</p>
<p>1） 基于<a href="aop:config">aop:config</a>的AOP配置</p>
<p>下面是一个典型的事务AOP的配置：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;tx:advice id="transactionAdvice" <span class="keyword">transaction</span>-manager="transactionManager"?&gt;</span><br><span class="line">    &lt;tx:attributes &gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="add*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="append*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="insert*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="save*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="update*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="get*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="find*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="load*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="search*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="*" propagation="SUPPORTS" /&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id="transactionPointcut" expression="execution(* net.aazj.service..*Impl.*(..))" /&gt;</span><br><span class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>="transactionPointcut" advice-<span class="keyword">ref</span>="transactionAdvice" /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"aspectBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.aazj.aop.DataSourceInterceptor"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect id=<span class="string">"dataSourceAspect"</span> ref=<span class="string">"aspectBean"</span>&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"dataSourcePoint"</span> expression=<span class="string">"execution(public * net.aazj.service..*.getUser(..))"</span> /&gt;</span><br><span class="line">        &lt;aop:pointcut expression=<span class="string">""</span> id=<span class="string">""</span>/&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"before"</span> pointcut-ref=<span class="string">"dataSourcePoint"</span>/&gt;</span><br><span class="line">        &lt;aop:after method=<span class="string">""</span>/&gt;</span><br><span class="line">        &lt;aop:around method=<span class="string">""</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/aop:aspect&gt;</span></span><br><span class="line"><span class="regexp">    &lt;aop:aspect&gt;&lt;/</span>aop:aspect&gt;</span><br><span class="line">&lt;<span class="regexp">/aop:config&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="aop:aspect">aop:aspect</a> 配置一个切面；</p>
<p><a href="aop:pointcut">aop:pointcut</a>配置一个切点，基于切点表达式；</p>
<p><a href="aop:before">aop:before</a>,<a href="aop:after">aop:after</a>,<a href="aop:around">aop:around</a>是定义不同类型的advise. a</p>
<p>spectBean 是切面的处理bean：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInterceptor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        DataSourceTypeManager.<span class="built_in">set</span>(DataSources.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>基于注解和@Aspect风格的AOP配置</li>
</ol>
<p>我们以事务配置为例：首先我们启用基于注解的事务配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用annotation定义事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后扫描Service包：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"net.aazj.service,net.aazj.aop"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>最后在service上进行注解：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">Service(<span class="string">"userService"</span>)</span></span><br><span class="line">@Transactional</span><br><span class="line">public <span class="keyword">class</span> UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    @Transactional (readOnly=<span class="literal">true</span>)</span><br><span class="line">    public User get<span class="constructor">User(<span class="params">int</span> <span class="params">userId</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"in UserServiceImpl getUser"</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">DataSourceTypeManager</span>.</span></span>get<span class="literal">()</span>);</span><br><span class="line">        return userMapper.get<span class="constructor">User(<span class="params">userId</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add<span class="constructor">User(String <span class="params">username</span>)</span>&#123;</span><br><span class="line">        userMapper.add<span class="constructor">User(<span class="params">username</span>)</span>;</span><br><span class="line"><span class="comment">//        int i = 1/0;    // 测试事物的回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">    public void delete<span class="constructor">User(<span class="params">int</span> <span class="params">id</span>)</span>&#123;</span><br><span class="line">        userMapper.delete<span class="constructor">ByPrimaryKey(<span class="params">id</span>)</span>;</span><br><span class="line"><span class="comment">//        int i = 1/0;    // 测试事物的回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">    @Transactional (rollbackFor = <span class="module-access"><span class="module"><span class="identifier">BaseBusinessException</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">    public void add<span class="constructor">AndDeleteUser(String <span class="params">username</span>, <span class="params">int</span> <span class="params">id</span>)</span> throws BaseBusinessException&#123;</span><br><span class="line">        userMapper.add<span class="constructor">User(<span class="params">username</span>)</span>;</span><br><span class="line">        this.m1<span class="literal">()</span>;</span><br><span class="line">        userMapper.delete<span class="constructor">ByPrimaryKey(<span class="params">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> void m1<span class="literal">()</span> throws BaseBusinessException &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BaseBusinessException(<span class="string">"xxx"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="built_in">int</span> insert<span class="constructor">User(User <span class="params">user</span>)</span> &#123;</span><br><span class="line">        return this.userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定。这种事务配置方式，不需要我们书写pointcut表达式，而是我们在需要事务的类上进行注解。但是如果我们自己来写切面的代码时，还是要写pointcut表达式。下面看一个例子(自己写切面逻辑)：</p>
<p>首先去扫描 @Aspect 注解定义的 切面：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"net.aazj.aop"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>切面代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Before</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Pointcut</span>;</span><br><span class="line">import org.springframework.core.<span class="keyword">annotation</span>.<span class="title">Order</span>;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Aspect    /<span class="regexp">/ for aop</span></span><br><span class="line"><span class="regexp">@Component /</span><span class="regexp">/ for auto scan</span></span><br><span class="line"><span class="regexp">@Order(0)  /</span><span class="regexp">/ execute before @Transactional</span></span><br><span class="line"><span class="regexp">public class DataSourceInterceptor &#123;</span></span><br><span class="line"><span class="regexp">    @Pointcut("execution(public * net.aazj.service..*.get*(..))")</span></span><br><span class="line"><span class="regexp">    public void dataSourceSlave()&#123;&#125;;</span></span><br><span class="line"><span class="regexp">    @Before("dataSourceSlave()")</span></span><br><span class="line"><span class="regexp">    public void before(JoinPoint jp) &#123;</span></span><br><span class="line"><span class="regexp">        DataSourceTypeManager.set(DataSources.SLAVE);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们使用到了 @Aspect 来定义一个切面；</p>
<p>@Component是配合<a href="context:component-scan/">context:component-scan/</a>，不然扫描不到；</p>
<p>@Order定义了该切面切入的顺序 ，因为在同一个切点，可能同时存在多个切面，那么在这多个切面之间就存在一个执行顺序的问题。</p>
<p>该例子是一个切换数据源的切面，那么他应该在 事务处理 切面之前执行，所以我们使用 @Order(0) 来确保先切换数据源，然后加入事务处理。</p>
<p>@Order的参数越小，优先级越高，默认的优先级最低：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation that defines ordering. The value is optional, and represents order value</span></span><br><span class="line"><span class="comment"> * as defined in the &#123;@link Ordered&#125; interface. Lower values have higher priority.</span></span><br><span class="line"><span class="comment"> * The default value is &#123;@code Ordered.LOWEST_PRECEDENCE&#125;, indicating</span></span><br><span class="line"><span class="comment"> * lowest priority (losing to any other specified order value).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Order &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The order value. Default is &#123;@link Ordered#LOWEST_PRECEDENCE&#125;.</span></span><br><span class="line"><span class="comment">     * @see Ordered#getOrder()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">value</span>() <span class="selector-tag">default</span> <span class="selector-tag">Ordered</span><span class="selector-class">.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3） 切点表达式(pointcut)</p>
<p>上面我们看到，无论是 <a href="aop:config">aop:config</a> 风格的配置，还是 @Aspect 风格的配置，切点表达式都是重点。都是我们必须掌握的。</p>
<p>1&gt;pointcut语法形式(execution)：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">execution(modifiers-<span class="built_in">pattern</span>? ret-type-<span class="built_in">pattern</span> declaring-type-<span class="built_in">pattern</span>? name-<span class="built_in">pattern</span>(param-<span class="built_in">pattern</span>)throws-<span class="built_in">pattern</span>?)</span><br></pre></td></tr></table></figure>
<p>带有 ? 号的部分是可选的，所以可以简化成： ret-type-pattern name-pattern(param_pattern) 返回类型，方法名称，参数三部分来匹配 。</p>
<p>配置起来其实也很简单： * 表示任意返回类型，任意方法名，任意一个参数类型； … 连续两个点表示0个或多个包路径，还有0个或多个参数 。就是这么简单。看下例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">execution</span>(* <span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span>..*<span class="selector-class">.get</span>*(..)) ：表示<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span>包或者子包下的以<span class="selector-tag">get</span>开头的方法，参数可以是0个或者多个（参数不限）；</span><br><span class="line"><span class="selector-tag">execution</span>(* <span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.AccountService</span>.*(..)): 表示<span class="selector-tag">AccountService</span>接口下的任何方法，参数不限；</span><br><span class="line">注意这里，将类名和包路径是一起来处理的，并没有进行区分，因为类名也是包路径的一部分。</span><br><span class="line">参数<span class="selector-tag">param-</span> <span class="selector-tag">pattern</span> 部分比较复杂： () 表示没有参数，(..)参数不限，(*,<span class="selector-tag">String</span>) 第一个参数不限类型，第二参数为<span class="selector-tag">String</span> .</span><br></pre></td></tr></table></figure>
<p>2&gt;within() 语法:</p>
<p>within()只能指定(限定)包路径(类名也可以看做是包路径)，表示某个包下或者子报下的所有方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(net.aazj.service.*)</span></span>， within(net<span class="selector-class">.aazj</span><span class="selector-class">.service</span>..*)，within(net<span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserServiceImpl</span>.*)</span><br></pre></td></tr></table></figure>
<p>3&gt;this() 与 target():</p>
<p>this是指代理对象，target是指被代理对象(目标对象)。所以 this() 和 target() 分别限定 代理对象的类型和被代理对象的类型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">this</span>(<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserService</span>): 实现了<span class="selector-tag">UserService</span>的代理对象(中的所有方法)； </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">target</span> (<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserService</span>): 被代理对象 实现了<span class="selector-tag">UserService</span>(中的所有方法)；</span><br></pre></td></tr></table></figure>
<p>4&gt; <em>args():</em></p>
<p>限定方法的参数的类型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">args</span>(<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.pojo</span><span class="selector-class">.User</span>): 参数为<span class="selector-tag">User</span>类型的方法。</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>&gt;@target(), @within(), @<span class="keyword">annotation</span>(), @<span class="title">args</span>():</span><br><span class="line"></span><br><span class="line">这些语法形式都是针对注解的 ，比如 带有某个注解的 类 ， 带有某个注解的 方法， 参数的类型 带有某个注解 ：</span><br><span class="line">@within(org.springframework.transaction.<span class="keyword">annotation</span>.<span class="title">Transactional</span>) </span><br><span class="line">@target(org.springframework.transaction.<span class="keyword">annotation</span>.<span class="title">Transactional</span>)</span><br></pre></td></tr></table></figure>
<p>两者都是指被代理对象 类 上有 @Transactional 注解的(类的所有方法)，（两者似乎没有区别？？？）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@annotation</span>(org.springframework.transaction.annotation.Transactional)：  方法 带有 <span class="variable">@Transactional</span> 注解的所有方法 </span><br><span class="line"></span><br><span class="line"><span class="variable">@args</span>(org.springframework.transaction.annotation.Transactional)： 参数的类型 带有 <span class="variable">@Transactional</span> 注解 的所有方法</span><br></pre></td></tr></table></figure>
<p>6&gt;bean(): 指定某个bean的名称</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bean(userService)</span>: bean的id为 "userService" 的所有方法;</span><br><span class="line"></span><br><span class="line"><span class="attribute">bean(*Service)</span>: bean的id为 "Service"字符串结尾的所有方法;</span><br><span class="line"></span><br><span class="line">另外注意上面这些表达式是可以利用 ||, &amp;&amp;, ! 进行自由组合的。比如：execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(Integer,..)</span><br></pre></td></tr></table></figure>
<p>\4. 向注解处理方法传递参数</p>
<p>有时我们在写注解处理方法时，需要访问被拦截的方法的参数。此时我们可以使用 args() 来传递参数，下面看一个例子：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component // <span class="keyword">for</span> auto scan</span><br><span class="line">//@<span class="keyword">Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LogInterceptor &#123;    </span><br><span class="line">    @Pointcut("execution(public * net.aazj.service..*.getUser(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> myMethod()&#123;&#125;;</span><br><span class="line">    @<span class="keyword">Before</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">before</span>() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method start");</span><br><span class="line">    &#125; </span><br><span class="line">    @<span class="keyword">After</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">after</span>() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method after");</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterReturning("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> AfterReturning() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method AfterReturning");</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterThrowing("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">//  @Around("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> AfterThrowing() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method AfterThrowing");</span><br><span class="line">    &#125; </span><br><span class="line">    @Around("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">Object</span> Around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method Around");</span><br><span class="line">        SourceLocation sl = jp.getSourceLocation();</span><br><span class="line">        <span class="keyword">Object</span> ret = jp.proceed();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getTarget());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">    @<span class="keyword">Before</span>("execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before3(<span class="type">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId-----" + userId);</span><br><span class="line">    &#125;  </span><br><span class="line">    @<span class="keyword">Before</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before2(JoinPoint jp) &#123;</span><br><span class="line">        <span class="keyword">Object</span>[] args = jp.getArgs();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId11111: " + (<span class="type">Integer</span>)args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getTarget());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getThis());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getSignature());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method start");</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before3(<span class="type">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId-----" + userId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它会拦截 net.aazj.service 包下或者子包下的getUser方法，并且该方法的第一个参数必须是int型的， 那么使用切点表达式args(userId,…) 就可以使我们在切面中的处理方法before3中可以访问这个参数。</p>
<p>before2方法也让我们知道也可以通过 JoinPoint 参数来获得被拦截方法的参数数组。 JoinPoint 是每一个切面处理方法都具有的参数， @Around 类型的具有的参数类型为ProceedingJoinPoint。通过 JoinPoint或者 ProceedingJoinPoint 参数可以访问到被拦截对象的一些信息(参见上面的 before2 方法)。</p>
<ol>
<li>
<p>请简述 Spring 框架的优点。</p>
<blockquote>
<p>**非侵入式设计:**Spring是一种非侵入式（non-invasive）框架，它可以使应用程序代码对框架的依赖最小化。</p>
</blockquote>
<blockquote>
<p>**方便解耦、简化开发:**Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护工作都交给Spring容器的管理，大大的降低了组件之间的耦合性。</p>
</blockquote>
<blockquote>
<p>**支持AOP:**Spring提供了对AOP的支持，它允许将一些通用任务，如安全、事物、日志等进行集中式处理，从而提高了程序的复用性。</p>
</blockquote>
<blockquote>
<p><strong>支持声明式事务处理</strong></p>
<p>只需要通过配置就可以完成对事物的管理，而无须手动编程。</p>
</blockquote>
<blockquote>
<p><strong>方便程序的测试</strong></p>
<p>Spring提供了对Junit4的支持，可以通过注解方便的测试Spring程序。</p>
</blockquote>
<blockquote>
<p><strong>方便集成各种优秀框架</strong></p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如Struts、Hibernate、MyBatis、Quartz等）的直接支持。</p>
</blockquote>
<blockquote>
<p><strong>降低Jave EE API的使用难度。</strong></p>
<p>Spring对Java EE开发中非常难用的一些API（如JDBC、JavaMail等），都提供了封装，使这些API应用难度大大降低。</p>
</blockquote>
</li>
<li>
<p>请简述什么是 Spring 的 loC 和DI。</p>
<blockquote>
<h4 id="ioc控制反转"><a class="markdownIt-Anchor" href="#ioc控制反转"></a> IOC（控制反转）</h4>
<p>传统的Java开发过程中，当需要一个对象的时候，我们需要自己new或者getInstance等直接或间接调用构造方法创建一个对象；而在Spring容器中，Spring容器利用 工厂模式(BeanFactory)为我们创建了所需要的对象，使用时无须自己创建，直接调用Spring为我们创建的对象即可，这就是控制反转的思想。</p>
<p><strong>优点</strong>：简化了我们对对象的管理，交给了Spring管理；程序员不用再自己创建对象，需要时直接从Spring中取。由主动创建对象变成了被动接收对象，控制权反转，减轻了程序员的代码量，提高了开发效率。打个比方：IOC就像现在得订餐APP，以前我们吃饭需要自己去做，去New一顿饭出来；现在我们有了订餐APP(Spring)，我们只需要登录这个APP，在APP订餐页面<code>spring.xml</code>(Spring配置文件)填写你想吃的饭(也就是Bean对象)，然后就可以预定你要吃的饭，想要猪头肉就会给你送猪头肉，想要红烧肉就会送红烧肉；各种菜就像是Property，这样我们坐在家中就可以吃到饭了，不用自己再动手去做了。</p>
</blockquote>
<blockquote>
<p><strong>DI(依赖注入)</strong></p>
<p>Spring为我们提供了三种注入方式：<a href="https://www.cnblogs.com/xiaoxi/p/5865330.html"><strong>Setter注入</strong>、<strong>构造方法注入</strong>、<strong>接口注入</strong></a></p>
<p>Spring使用JavaBean对象的Set方法或者带参数的构造方法为我们创建所需要的对象时将其属性自动设置为所需要的值的过程就是依赖注入的思想。</p>
<p><strong>优点</strong>：有了Spring容器，当我们想要创建一个Service时，就可以直接从Spring容器中拿；或者想在Service中调用Dao也不需要在Service里创建，因为Spring会从容器中取出Dao，并注入到Service里，也就是依赖注入。</p>
</blockquote>
<blockquote>
<h4 id="aop面向切面编程"><a class="markdownIt-Anchor" href="#aop面向切面编程"></a> AOP（面向切面编程）</h4>
<p>在面向对象编程(OOP)中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如：权限验证，事务管理，记录日志等公用操作处理的过程就是面向切面编程的思想。</p>
</blockquote>
</li>
<li>
<p>请简述 Bean 的生命周期。</p>
</li>
</ol>
<blockquote>
<ol>
<li>实例化bean对象(通过构造方法或者工厂方法)</li>
<li>设置对象属性(setter等)（依赖注入）</li>
<li>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）</li>
<li>如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</li>
<li>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法</li>
<li>调用Bean的初始化方法</li>
<li>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</li>
<li>使用Bean</li>
<li>容器关闭之前，调用Bean的销毁方法</li>
</ol>
</blockquote>
<ol start="4">
<li>
<p>请简述 Bean 的几种装配方式的基本用法。</p>
<blockquote>
<p><strong>1基于XML的装配</strong><br>
基于XML的装配，Spring提供了两种装配方式：设值注入（Setter Injection）和构造注入（Constructor Injection）。<br>
设值注入要求Bean必须满足一下要求：<br>
（1）Bean类必须提供一个默认的无参构造方法；<br>
（2）Bean类必须为需要注入的属性提供对应的setter方法；<br>
设值注入时，需要Spring在配置文件中，需要使用元素的子元素来为每个属性注入值；<br>
使用构造方法时，在配置文件里，需要使用元素的子元素来定义构造方法的参数，可以使用value属性（或者子元素）来设值该参数的值。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">见第二章代码  <span class="selector-tag">beans5</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2基于Annotation的装配</strong><br>
在实际应用中如果有很多Bean时，还通过使用XML配置会导致臃肿，给后续的维护和升级带来一定的困难。Spring提供了对Annotation注解技术的全面支持，可以解决此困难。</p>
</blockquote>
<p>Spring常用注解如下：</p>
<table>
<thead>
<tr>
<th><strong>Component</strong></th>
<th><strong>描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次；</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Repository</td>
<td>用于将数据访问层（DAO）层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Service</td>
<td>作用在业务层（service层），用于将业务层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Controller</td>
<td>作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Autowired</td>
<td>用于对Bean的属性变量、属性setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作</td>
</tr>
<tr>
<td>Resourse</td>
<td>作用与Autowired一样。Resourse两个重要的属性：name和type。Spring将name解析为Bean实例名称，type解析为Bean实例类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>3自动装配</strong><br>
自动装配，就是将一个bean自动地注入到其他Bean的property中。<br>
仿造如上示例二代码，在ServiceImpl.java和UserController.java中加入属性的Setter方法。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBean</title>
    <url>/2020/03/03/StringBean/</url>
    <content><![CDATA[<h3 id="1bean"><a class="markdownIt-Anchor" href="#1bean"></a> 1.Bean</h3>
<p>​		Spring 可以被看作是一个大型工厂，这个工厂的作用就是生产和管理 Spring 容器中的 Bean。 如果想要在项目中使用这个工厂，就需要开发者对 Spring 的配置文件进行配置。 Spring 容器支持 XML 和 Properties 两种格式的配置文件，在实际开发中，最常使用的就是 XML 格式的配置方式。这种配置方式通过 XML 文件来注册并管理 Bean 之间的依赖关系。 接下 来本小节将使用 XML 文件的形式对 Bean 的属性和定义进行详细的讲解。 在 Spring 中， XML 配置文件的根元素是<beans> ， <beans>中包含了多个<bean>子元素， 每一个<bean>子元素定义了一个 Bean ，并描述了该 Bean 如何被装配到 Spring 容器中。</bean></bean></beans></beans></p>
<p><bean>元素中同样包含了多个属性以及子元素</bean></p>
<a id="more"></a>
<!--more-->
<table>
<thead>
<tr>
<th>属性或子元素名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>是一个 Bean 的唯一标识符， Spring 窑器对 Bean 的配置、 筐理部通过该属性来完成</td>
</tr>
<tr>
<td>name</td>
<td>Spring 窑器同样可以通过此属性对容器中的 Bean 进行配置和管理， name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td>
</tr>
<tr>
<td>class</td>
<td>该属性指定了 Bean 的具体实现类， E必须是一个完整的类毡，使用类的全限定名</td>
</tr>
<tr>
<td>scope</td>
<td>用来设定 Bean 实例的作用域，莫属性值有: singleton( 单例)、 prototype( 原型)、 request、 sesslon、 global Session , application 和 websocket. 真默认值为 singleton</td>
</tr>
<tr>
<td>constructor-arg</td>
<td><bean>元素的子元素，可以使用此元素传入构造参数进行实例化。 该元素的 index 属性指 定构造参数的序号(从 O 开始) , type 属性指定构造参数的类型，参数值可以通过 ref 属性 或 value 属性直接指定，也可以通过 ref 或 value 子元素指定</bean></td>
</tr>
<tr>
<td>property</td>
<td><bean>元素的子元素， 用于调用 Bean 实例中的 setter 方法完成属性赋值，从而完成依赖注入。 该元素的 name 属性指定 Bean 实例中的相应属性毡 ref 属性或 value 属性用于 指定参数值</bean></td>
</tr>
<tr>
<td>ref</td>
<td><property>、 <constructor-arg>等元素的属性或子元素，可以用于指定对 Bean 工厂中 某个 Bean 实例的引用</constructor-arg></property></td>
</tr>
<tr>
<td>value</td>
<td><property>、 <constructor-arg>等元素的属性或子元素，可以用于直接指定一个常量值</constructor-arg></property></td>
</tr>
<tr>
<td>list</td>
<td>用于封装List 或数组类型的依赖注入</td>
</tr>
<tr>
<td>set</td>
<td>用于封装 Set 类型属性的依赖注入</td>
</tr>
<tr>
<td>map</td>
<td>用于封装 Map 类型属性的依赖注入</td>
</tr>
<tr>
<td>entry</td>
<td><map>元素的子元素，用于设置一个键值对。 真 key 属性指定字符串类型的键值， ref 或 value 子元素指定真僵，也可以通过 value-ref 或 value 属性指定真值</map></td>
</tr>
</tbody>
</table>
<p>如果在 Bean 中未指定 id 和 nam巳， 则 Spri吨会将c1ass值当作 id 使用。</p>
<h4 id="静态工厂方式实例化"><a class="markdownIt-Anchor" href="#静态工厂方式实例化"></a> 静态工厂方式实例化</h4>
<p>使用静态工厂是实例化 Bean 的另一种方式。 该方式要求开发者创建一个静态工厂的方法来 创建 Bean 的实例，其 Bean 配置中的 class 属性所指定的不再是 Bean 实例的实现类，而是静 态工厂类，同时还需要使用 factory-method 属性来指定所创建的静态工厂方法。 下面通过一个 案例来演示如何使用静态工厂方式实例化 Bean。</p>
<h4 id="实例工厂方式实例化"><a class="markdownIt-Anchor" href="#实例工厂方式实例化"></a> 实例工厂方式实例化</h4>
<p>还有一种实例化 Bean 的方式就是采用实例工厂。 此种方式的工厂类中，不再使用静态方法 创建 Bean 实例，而是采用直接创建 Bean 实例的方式。 同时，在配置文件中，需要实例化的 Bean 也不是通过 class 属性直接指向的实例化类，而是通过 factory- bean 属性指向配置的实例工厂， 然后使用 factory- method 属性确定使用工厂中的哪个方法。 下面通过一个案例来演示实例工厂 方式的使用。</p>
<h3 id="2bean的作用域"><a class="markdownIt-Anchor" href="#2bean的作用域"></a> 2.Bean的作用域</h3>
<table>
<thead>
<tr>
<th>作用域名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton(单例)</td>
<td>使用 singleton 定义的 Bean 在 Spring 窑器中将只有一个实例， 也就是说，无论有多少个 Bean 引用巴，始终将指向罔一个对象。 这也是 Spring 窑器默认的作用域</td>
</tr>
<tr>
<td>prototype (原型)</td>
<td>每次通过 Spring 窑器获取的 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例</td>
</tr>
<tr>
<td>request</td>
<td>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。 对不同的 HTTP 请求则会产生一个新的 Bean ，而且该 Bean 仅在当前 HTTP Request 内奇效</td>
</tr>
<tr>
<td>sesslon</td>
<td>在 一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。 对不同的 HTTPi需求则会产 生一个新的 Bean ，而且该 Bean 仅在当前 HTTP Sessio门内奇效</td>
</tr>
<tr>
<td>globalSession</td>
<td>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。 仅在使用 portlet 上下 文时有效</td>
</tr>
<tr>
<td>application</td>
<td>为每个 ServletContext 对象创建一个实例。 仅在 Web 相关的 ApplicationContext 中生效</td>
</tr>
<tr>
<td>websocket</td>
<td>为每个 websocket 对象创建一个实例。 仅在 Web 徊关的 ApplicationContext 中生效</td>
</tr>
</tbody>
</table>
<h4 id="1-singeton作用域"><a class="markdownIt-Anchor" href="#1-singeton作用域"></a> 1. singeton作用域</h4>
<p>singleton 是 Spring 容器默认的作用域，当 Bean 的作用域为 singleton 肘， Spring 容器就 只会存在一个共享的 Bean 实例，并且所有对 Bean 的请求，只要 id 与该 Bean 的 id 属性相匹配， 就会返回同一个 Bean 实例。 singleton 作用域对于无会话状态的 Bean (如 Dao 组件、 Service 组件)来说，是最理想的选择。</p>
<p>需要注意的是，如果不设置 scope=划ngleton&quot; ，其输出结果也是一个实例，因为 Spring 容 器默认的作用域就是 singleton。</p>
<h4 id="2-prototype作用域"><a class="markdownIt-Anchor" href="#2-prototype作用域"></a> 2. prototype作用域</h4>
<p>对需要保持会话状态的 Bean (如 Struts2 的 Action 类)应该使用 prototype 作用域。 在使 用 prototype 作用域时， Spring 容器会为每个对该 Bean 的请求都创建一个新的实例。</p>
<h4 id="3bean的生命周期"><a class="markdownIt-Anchor" href="#3bean的生命周期"></a> 3.Bean的生命周期</h4>
<p>(1)根据配置情况调用 Bean 构造方法或工厂方法实例化 Beano</p>
<p>(2)利用依赖注入完成 Bean 中所有属性值的配置注入。</p>
<p>(3)如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanNameO方 法传入当前 Bean 的 id 值。</p>
<p>(4)如果 Bean 实现了 BeanFactory Aware 接口，则 Spring 调用 setBeanFactoryO方法传 入当前工厂实例的引用。</p>
<p>(5)如果 Bean 实现了 ApplicationContextAware 接口，贝IJ Spring 调用 setApplicationContextO 方法传入当前 ApplicationContext 实例的引用。</p>
<p>(6 )如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforel n itialzationO对 Bean 进行加工操作，这个非常重要， Spring 的 AOP 就是用 它实现的。</p>
<p>(7 )如果 Bean 另见了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet()方法。<br>
(8 )如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。 (9 )如果有 BeanPostProcessor 和 Bean 关联，贝IJ Spring 将调用该接口的初始化方法 post ProcessAfterlnitialization()。 此时， Bean 已经可以被应用系统使用了。</p>
<p>(10 )如果在<bean> 中指定了该 Bean 的作用范围为 scope=“singleton” ，则将该 Bean 放 入 Spring loC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理;如果在<bean>中指定了 该 Bean 的作用范围为 scope=“prototype” ，贝IJ将该 Bean 交给调用者，调用者管理该 Bean 的生 命周期， Spring 不再管理该 Bean。</bean></bean></p>
<p>(11)如果 Bean 实现了 DisposableBean 接口，贝IJ Spring 会调用 destory()方法将 Spring 中的 Bean 销毁;如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法进行销毁。</p>
<p>Spring 为 Bean 提供了细致全面的生命周期过程，通过实现特定的接口或通过<bean>的属 性设置，都可以对 Bean 的生命周期过程产生影响。 我们可以随意地配置<bean>的属性，但是 在这里建议不要过多地使用 Bean 实现接口，因为这样会使代码和 Spring 聚合比较紧密。</bean></bean></p>
<h3 id="3bean的装配方式"><a class="markdownIt-Anchor" href="#3bean的装配方式"></a> 3.Bean的装配方式</h3>
<h4 id="1基于xml"><a class="markdownIt-Anchor" href="#1基于xml"></a> 1.基于xml</h4>
<p>Spring 提供了两种基于 XML 的装配方式:设值注入( Setter Injection )和构造注入 ( Constructor Injection )。 下面就讲解下如何在 XML 配置文件中使用这两种注入方式来实现基于 XML 的装配。</p>
<p>在 Spring 实例化 Bean 的过程中， Spring 首先会调用 Bean 的默认构造方法来实例化 Bean 对象，然后通过反射的方式调用 setter 方法来注入属性值。 因此，设值注入要求一个 Bean 必须 满足以下两点要求。</p>
<p>• Bean 类必须提供一个默认的无参构造方法。</p>
<p>• Bean 类必须为需要注入的属性提供对应的 setter 方法。</p>
<p>使用设值注入时，在 Spring 配置文件中，需要使用<bean>元素的子元素<property>来为每 个属性注入值;而使用构造注入时，在配置文件里，需要使用 <bean> 元素的子元素 &lt;constructor -arg&gt;来定义构造方法的参数，可以使用其 value 属性(或子元素)来设置该参数 的值。 下面通过一个案例来演示基于 XML 方式的 Bean 的装配。</bean></property></bean></p>
<h4 id="2基于annotation装配"><a class="markdownIt-Anchor" href="#2基于annotation装配"></a> 2.基于Annotation装配</h4>
<p>在 Spring 中，尽管使用 XML配置文件可以实现 Bean 的装配工作，但如果应用中有很多 Bean 时，会导致 XML 配置文件过于靡肿，给后续的维护和升级工作带来一定的困难。 为此， Spring 提供了对 Annotation (注解)技术的全面支持。 Spring 中定义了一系列的注解，常用的注解如下所示。</p>
<p>• @Component: 可以使用此注解描述 Spring 中的 Bean ，但它是一个泛化的概念，仅仅表 示一个组件 (Bean l，并且可以作用在任何层次。 使用时只需将该注解标注在相应类上即可。</p>
<p>• @Repository: 用于将数据访问层( DAO 层)的类标识为 Spring 中的 Bean ，其功能与 @Component 相同。</p>
<p>• @Service: 通常作用在业务层( Service 层 l，用于将业务层的类标识为 Spring 中的 Bean ， 其功能与@Component 相同。</p>
<p>• @Controller: 通常作用在控制层(如 Spring MVC 的 Controller l，用于将控制层的类标识 为 Spring 中的 Bean ，其功能与@Component 相同。</p>
<p>• @Autowired: 用于对 Bean 的属性变量、属性的 setter 方法及构造方法进行标注，配合对 应的注解处理器完成 Bean 的自动配置工作。 默认按照 Bean 的类型进行装配。</p>
<p>• @Resource: 其作用与 Autowired 一样。 其区别在于@Autowired 默认按照 Bean 类型装 配，而@Resource 默认按照 Bean 实例名称进行装配。 @Resource 中有两个重要属性: name 和 typeo Spring 将 name 属性解析为 Bean 实例名称， type 属性解析为 Bean 实例类型。 如果 指定 name 属性，贝IJ按实例名称进行装配;如果指定 type 属性，则按 Bean 类型进行装配;如 果都不指定，则先按 Bean 实例名称装配，如果不能匹配，再按照 Bean 类型进行装自己;如果都 无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</p>
<p>• @Qualifier: 与@Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为接 Bean 的实例名称装配， Bean 的实例名称由@Qualifier 注解的参数指定。</p>
<p>在上面几个注解中，虽然@Repository、 @Service 与@Controller 功能与@Component 注解 的功能相同，但为了使标注类本身用途更加清晰，建议在实际开发中使用@Repository、 @Service 与@Controller 分别对实现类进行标注。</p>
<h4 id="3自动装配"><a class="markdownIt-Anchor" href="#3自动装配"></a> 3.自动装配</h4>
<p>虽然使用注解的方式装配 Bean ，在一定程度上减少了配置文件中的代码量，但是也有企业项目中， 是没有使用注解方式开发的，那么有没有什么办法既可以减少代码量，又能够实现 Bean 的装配呢?</p>
<p>答案是肯定的， Spring 的 <bean>元素中包含一个 autowire 属性，我们可以通过设置 autowire 的属性值来自动装配 Bean。 所谓自动装配，就是将一个 Bean 自动地注入到其他 Bean 的 Property 中。</bean></p>
<p><bean>元素的 autowire 属性值及说明</bean></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>由 <bean> 的上级标签 <beans> 的 default-autowire 属 性值确定 。 例如 <beans defaultautowire="byName"> ，则该<bean>元素中的 autowire 属性对应的属性值就为 byName</bean></beans></beans></bean></td>
</tr>
<tr>
<td>byName</td>
<td>根据属性的名称自动装配。 窑器将根据名称查找与属性完全一致的 Bean ，并将真属性自动装配</td>
</tr>
<tr>
<td>byType</td>
<td>根据属性的数据类型 (Type) 自动装配，如果一个 Bean 的数据类型，兼容另一个 Bean 中属性的 数据类型，则自动装配</td>
</tr>
<tr>
<td>constructor</td>
<td>根据何造函数参数的数据类型，进行 byType 模式的自动装配</td>
</tr>
<tr>
<td>no</td>
<td>在默认情况下，不使用自动装配， Bean 依赖必须通过 ref 元素定义</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
      <tags>
        <tag>犯过的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性</title>
    <url>/2020/03/03/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>jdk1.8新特性主要:</p>
<blockquote>
<ul>
<li><strong>Lambda表达式</strong></li>
<li><strong>函数式接口</strong></li>
<li><strong>方法引用和构造器调用</strong></li>
<li><strong>Stream API</strong></li>
<li><strong>接口中的默认方法和静态方法</strong></li>
<li><strong>新时间日期API</strong></li>
</ul>
</blockquote>
<h2 id="一-lambda表达式"><a class="markdownIt-Anchor" href="#一-lambda表达式"></a> 一   Lambda表达式</h2>
<blockquote>
<p>lambda表达式本质上是一段匿名内部类, 也可以是一段可以传递的代码</p>
</blockquote>
<p>lambda最直观的优点:  简洁代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"========================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure>
<p>​		这样一个场景，在商城浏览商品信息时，经常会有条件的进行筛选浏览，例如要选颜色为红色的、价格小于8000千的….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选颜色为红色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Product&gt; <span class="title">filterProductByColor</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Product product : list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"红色"</span>.equals(product.getColor()))&#123;</span><br><span class="line">            prods.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prods;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选价格小于8千的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Product&gt; <span class="title">filterProductByPrice</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Product product : list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (product.getPrice() &lt; <span class="number">8000</span>)&#123;</span><br><span class="line">            prods.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prods;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对这个场景进行优化</p>
<p>**优化一: **使用设计模式</p>
<p>定义一个MyPredicate接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>MyPredicate &lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要筛选颜色为红色的商品,定义一个颜色过滤类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPredicate</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span> &lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RED = <span class="string">"红色"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> RED.equals(product.getColor());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>定义过滤方法，将过滤接口当做参数传入，这样这个过滤方法就不用修改，在实际调用的时候将具体的实现类传入即可。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;Product&gt; filterProductByPredicate(<span class="built_in">List</span>&lt;Product&gt; <span class="built_in">list</span>,MyPredicate&lt;Product&gt; mp)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;Product&gt; prods = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        for (Product prod : <span class="built_in">list</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>例如，如果想要筛选价格小于8000的商品，那么新建一个价格过滤类既可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">PricePredicate</span> <span class="symbol">implements</span> <span class="symbol">MyPredicate</span>&lt;<span class="symbol">Product</span>&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean test(Product product) &#123;</span><br><span class="line">        <span class="keyword">return</span> product.getPrice() &lt; <span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实现的话，每次变更需求都需要新建一个实现类，感觉还是有点繁琐，那么再来优化一下</p>
<p>**优化二:**使用匿名内部类</p>
<p>定义过滤方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">filterProductByPredicate</span><span class="params">(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp)</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Product prod : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用过滤方法时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按价格过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filterProductByPredicate(proList, <span class="keyword">new</span> MyPredicate&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> product.getPrice() &lt; <span class="number">8000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 按颜色过滤</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     filterProductByPredicate(proList, <span class="keyword">new</span> MyPredicate&lt;Product&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"红色"</span>.equals(product.getColor());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用匿名内部类, 就不需要每次都新建一个实现类, 直接在方法内部实现. 看到匿名内部类, 不禁想起了Lambda表达式.</p>
<p>**优化三:**使用Lambda表达式</p>
<p>定义过滤方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">filterProductByPredicate</span><span class="params">(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp)</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Product prod : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式进行过滤</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> test4()&#123;</span><br><span class="line">      List&lt;Product&gt; products = filterProductByPredicate<span class="function"><span class="params">(proList, (p) -&gt; p.getPrice() &lt; <span class="number">8000</span>)</span>;</span></span><br><span class="line"><span class="function">      <span class="title">for</span> <span class="params">(Product pro : products)</span>&#123;</span></span><br><span class="line"><span class="function">          <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(pro)</span>;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>在jdk1.8中还有更加简便的操作 Stream API</p>
<p>**优化四:**使用Stream API</p>
<p>可以不用定义过滤方法,直接在集合上进行操作</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">// 使用jdk1.8中的Stream API进行集合的操作</span></span><br><span class="line"><span class="regexp">@Test</span></span><br><span class="line"><span class="regexp">public void test()&#123;</span></span><br><span class="line"><span class="regexp">    //</span> 根据价格过滤</span><br><span class="line">    proList.stream()</span><br><span class="line">           .fliter<span class="function"><span class="params">((p) -&gt; p.getPrice() &lt;<span class="number">8000</span>)</span></span></span><br><span class="line"><span class="function">           .<span class="title">limit</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 根据颜色过滤</span></span><br><span class="line"><span class="function">    <span class="title">proList</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           .<span class="title">fliter</span><span class="params">((p) -&gt; <span class="string">"红色"</span>.equals(p.getColor()))</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 遍历输出商品名称</span></span><br><span class="line"><span class="function">    <span class="title">proList</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           .<span class="title">map</span><span class="params">(Product::getName)</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Lmabda表达式的语法总结： () -&gt; ();</p>
<table>
<thead>
<tr>
<th style="text-align:center">前置</th>
<th style="text-align:center">语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无参数无返回值</td>
<td style="text-align:center">()-&gt;System.out.println(“hello”)</td>
</tr>
<tr>
<td style="text-align:center">有一个参数无返回值</td>
<td style="text-align:center">(x)-&gt;System.out.println(x)</td>
</tr>
<tr>
<td style="text-align:center">有且只有一个参数无返回值</td>
<td style="text-align:center">x-&gt;System.out.println(x)</td>
</tr>
<tr>
<td style="text-align:center">有多个参数,有返回值,有多条lambda体语句</td>
<td style="text-align:center">(x,y) -&gt; {System.out.println(“xx”);return xx;};</td>
</tr>
<tr>
<td style="text-align:center">有多个参数,有返回值,只有一条lambda体语句</td>
<td style="text-align:center">(x,y)-&gt; xxxx</td>
</tr>
</tbody>
</table>
<p>口诀：左右遇一省括号，左侧推断类型省</p>
<p>注：当一个接口中存在多个抽象方法时，如果使用lambda表达式，并不能智能匹配对应的抽象方法，因此引入了函数式接口的概念</p>
<h2 id="二-函数式接口"><a class="markdownIt-Anchor" href="#二-函数式接口"></a> 二 <strong>函数式接口</strong></h2>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>MD插入图片</title>
    <url>/2020/03/03/MarkDown/</url>
    <content><![CDATA[<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片下缀</span>](<span class="link">xxx名字/图片名字.格式</span>)</span><br></pre></td></tr></table></figure>
<p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code></p>
<p>xxx指的是要插入的MD的文件名的文件夹</p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>常见操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注入</title>
    <url>/2020/03/02/Spring%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="error"><a class="markdownIt-Anchor" href="#error"></a> Error:</h4>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">" "</span> <span class="built_in">class</span>=<span class="string">" "</span>/&gt;    || &lt;bean <span class="built_in">id</span>=<span class="string">" "</span> <span class="built_in">class</span>=<span class="string">""</span>&gt; &lt;<span class="keyword">property</span>&gt; &lt;/<span class="keyword">property</span>&gt;&lt;/bean&gt;均可</span><br></pre></td></tr></table></figure>
<h5 id="1-依赖注入"><a class="markdownIt-Anchor" href="#1-依赖注入"></a> 1 依赖注入</h5>
<p>依赖注入的作用是在使用 Spring 框架创建对象时,动态地将其所依赖的对象注入 Bean 组件中, 其实现方式通常有两种, 一种是属性 setter 方法注入, 另一种是构造方法注入.</p>
<h6 id="setter方法注入"><a class="markdownIt-Anchor" href="#setter方法注入"></a> setter方法注入</h6>
<blockquote>
<ul>
<li>Spring 容器使用 setter 方法注入被依赖的实例. 通过调用无参构造器或无参静态工厂方法实例化Bean 后, 调用该Bean 的setter方法, 即可实现基于setter方法依赖的注入</li>
</ul>
</blockquote>
<h6 id="构造方法注入"><a class="markdownIt-Anchor" href="#构造方法注入"></a> 构造方法注入</h6>
<blockquote>
<ul>
<li>指Spring 容器使用构造方法注入被依赖的实例</li>
</ul>
</blockquote>
<a id="more"></a>
<p>本章代码小结:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line">package com.itheima.ioc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">            ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">            UserDao userDao=(UserDao) applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">            userDao.say();</span><br><span class="line">            UserService userService=(UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">            userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDaoImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Userdao say hellpo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span>  <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.say();</span><br><span class="line">        System.out.println(<span class="string">"uSERdao server say heellpo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
      <tags>
        <tag>犯过的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>树（Tree）是n（n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：<br>
1）有且仅有一个特定的称为根（Root）的结点；<br>
2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p>
<p>此外，树的定义还需要强调以下两点：<br>
1）n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。<br>
2）m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</p>
<p>二叉树性质<br>
1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）<br>
2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）<br>
3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>
4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>
5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p>
<p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br>
(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；<br>
(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</p>
<a id="more"></a>
<p>树的基础结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">​	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">​	Typedef val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> va)&#123;val=va;left==<span class="literal">nullptr</span>;right==<span class="literal">nullptr</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树的创建"><a class="markdownIt-Anchor" href="#二叉树的创建"></a> 二叉树的创建</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(TreeNode* t,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ve.<span class="built_in">size</span>()==i)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    t=<span class="keyword">new</span> TreeNode(ve[i++]);</span><br><span class="line">    createTree(t-&gt;left,ve,i);</span><br><span class="line">    createTree(t-&gt;right,ve,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树的几种遍历方式"><a class="markdownIt-Anchor" href="#二叉树的几种遍历方式"></a> <strong>二叉树的几种遍历方式</strong></h5>
<table>
<thead>
<tr>
<th>前序遍历</th>
<th>根左右</th>
<th>dfs</th>
</tr>
</thead>
<tbody>
<tr>
<td>中序遍历</td>
<td>左根右</td>
<td>dfs</td>
</tr>
<tr>
<td>后序遍历</td>
<td>右根左</td>
<td>dfs</td>
</tr>
<tr>
<td>层序遍历</td>
<td>一层一层遍历</td>
<td>bfs</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==nullprt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PreOrderTraverse(t-&gt;left);</span><br><span class="line">    PreOrderTraverse(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(t-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraverse(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(t-&gt;left);</span><br><span class="line">    PostOrderTraverse(t-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br></pre></td></tr></table></figure>
<p>递归算法时间复杂度往往太高.</p>
<p>使用非递归算法,先序中序后序,则需要借助栈来实现,层序遍历需借助队列来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归先序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PreOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    Stack&lt;TreeNode*&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            ve.push_back(t-&gt;val);</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ve;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">InOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            ve.push_back(t-&gt;val);</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归后序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">LastOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* temp;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            temp=s.pop();</span><br><span class="line">            <span class="keyword">if</span>((t-&gt;right==nullprt)||(t-&gt;right-&gt;val==ve.back()))&#123;</span><br><span class="line">              	ve.push_back(t-&gt;val)</span><br><span class="line">                temp=nullprt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.push(t);</span><br><span class="line">                t=t-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">SeqTraverse</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()||t)&#123;</span><br><span class="line">        TreeNode* w=q.pop();</span><br><span class="line">        ve.push_back(w-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(w-&gt;left)</span><br><span class="line">            q.push(w-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(w-&gt;right)</span><br><span class="line">            q.push(w-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断二叉树的深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">max</span>(<span class="number">1</span>+TreeDepth(pRoot&gt;left),<span class="number">1</span>+TreeDepth(pRoot-&gt;right));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/2020/03/01/categories/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于面试的问题</title>
    <url>/2020/03/01/C/</url>
    <content><![CDATA[<h1 id="以后要准备充分再面试"><a class="markdownIt-Anchor" href="#以后要准备充分再面试"></a> 以后要准备充分再面试</h1>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap实现原理分析</title>
    <url>/2020/03/01/JAVA%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<h2 id="1-hashmap的数据结构"><a class="markdownIt-Anchor" href="#1-hashmap的数据结构"></a> 1. HashMap的数据结构</h2>
<h4 id="11数组"><a class="markdownIt-Anchor" href="#11数组"></a> 1.1数组</h4>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</p>
<h4 id="12链表"><a class="markdownIt-Anchor" href="#12链表"></a> 1.2链表</h4>
<p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。<strong>链表</strong>的特点是：寻址困难，插入和删除容易。</p>
<h4 id="13哈希表"><a class="markdownIt-Anchor" href="#13哈希表"></a> 1.3哈希表</h4>
<p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
<p>哈希表是由<strong>数组+链表</strong>组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。</p>
<h2 id="hashmap里面实现一个静态内部类entry其重要的属性有-key-value-next从属性keyvalue我们就能很明显的看出来entry就是hashmap键值对实现的一个基础bean我们上面说到hashmap的基础就是一个线性数组这个数组就是entrymap里面的内容都保存在entry里面"><a class="markdownIt-Anchor" href="#hashmap里面实现一个静态内部类entry其重要的属性有-key-value-next从属性keyvalue我们就能很明显的看出来entry就是hashmap键值对实现的一个基础bean我们上面说到hashmap的基础就是一个线性数组这个数组就是entrymap里面的内容都保存在entry里面"></a> HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</h2>
<a id="more"></a>
<h2 id="2-hashmap的存取实现"><a class="markdownIt-Anchor" href="#2-hashmap的存取实现"></a> 2. HashMap的存取实现</h2>
<p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">// 存储时:</span><br><span class="line"><span class="built_in">int</span> hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的<span class="built_in">int</span>值</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">index</span> = hash % <span class="built_in">Entry</span>[].length;</span><br><span class="line"><span class="built_in">Entry</span>[<span class="built_in">index</span>] = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">// 取值时:</span><br><span class="line"><span class="built_in">int</span> hash = key.hashCode();</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">index</span> = hash % <span class="built_in">Entry</span>[].length;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Entry</span>[<span class="built_in">index</span>];</span><br></pre></td></tr></table></figure>
<h4 id="21-put"><a class="markdownIt-Anchor" href="#21-put"></a> 2.1 put</h4>
<p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？<br>
　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>); <span class="comment">//null总是放在数组的第一个链表中</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//如果key在链表中已存在，则替换为新value</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">                V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, <span class="keyword">value</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, e); <span class="comment">//参数e, 是Entry.next</span></span><br><span class="line">    <span class="comment">//如果size超过threshold，则扩充table大小。再散列</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>
<h4 id="22-get"><a class="markdownIt-Anchor" href="#22-get"></a> 2.2 get</h4>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="comment">//先定位到数组元素，再遍历该元素处的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            <span class="keyword">Object</span> k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23-null-key的存取"><a class="markdownIt-Anchor" href="#23-null-key的存取"></a> 2.3 null key的存取</h4>
<p>null key总是存放在Entry[]数组的第一个元素。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span>(<span class="params">V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">                V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">value</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-确定数组index-hashcode-tablelength取模"><a class="markdownIt-Anchor" href="#24-确定数组index-hashcode-tablelength取模"></a> 2.4 确定数组index: hashcode % table.length取模</h4>
<p>HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>按位取并，作用上相当于取模mod或者取余%。</p>
<p>这意味着数组下标相同，并不表示hashCode相同。</p>
<h4 id="25-table初始大小"><a class="markdownIt-Anchor" href="#25-table初始大小"></a> 2.5 table初始大小</h4>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> HashMap(<span class="built_in">int</span> initialCapacity, <span class="built_in">float</span> loadFactor) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="built_in">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="built_in">int</span>)(capacity * loadFactor);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意table初始大小并不是构造函数中的initialCapacity！！</strong></p>
<p><strong>而是 &gt;= initialCapacity的2的n次幂！！！！</strong></p>
<h2 id="3解决hash冲突的方法"><a class="markdownIt-Anchor" href="#3解决hash冲突的方法"></a> 3.解决hash冲突的方法</h2>
<ol>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立一个公共溢出区</li>
</ol>
<p>Java中hashmap的解决方法就是采用的链地址法</p>
<h4 id="31链地址法"><a class="markdownIt-Anchor" href="#31链地址法"></a> 3.1链地址法</h4>
<p>连地址处理冲突：将产生冲突的值以链表的形式连起来</p>
<p>好处：不会产生堆积，适合无法确定表长的情况，但是会增加空间消耗（指针需要空间）</p>
<p>方法：采用结构体数组的方式，首先将结构体内每一个元素赋值 -1 NULL，然后采用插入的方式产生链表，同一个函数值得元素在一条链表上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ha</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Ha</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Ha;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Ha ha[],<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ha *p=&amp;ha[k];</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next !=<span class="literal">NULL</span>)  <span class="comment">//始终存在 -1，NULL的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next ;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data =num;</span><br><span class="line">	Ha *q=<span class="keyword">new</span> Ha;</span><br><span class="line">	q-&gt;data =<span class="number">-1</span>;</span><br><span class="line">	q-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;next=q ;     <span class="comment">//注意先申请空间，然后再赋给上一节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serch</span><span class="params">(Ha ha[],<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ha *p=&amp;ha[k];</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data ==num)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		p=p-&gt;next ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;  <span class="comment">//整条链表没有所要找的值</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="string">","</span>&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	Ha ha[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ha[i].data =<span class="number">-1</span>;</span><br><span class="line">		ha[i].next =<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">		insert(ha,num%n,num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">	serch(ha,x%n,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4再散列rehash的过程"><a class="markdownIt-Anchor" href="#4再散列rehash的过程"></a> 4.再散列rehash的过程</h2>
<p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">     *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">     *        is irrelevant).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span><span class="type"></span> Entry[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">        transfer(<span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">        table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">        threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="comment">//重新计算index</span></span><br><span class="line">                    int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">                    e.next = <span class="keyword">new</span><span class="type">Table</span>[i];</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Table</span>[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA垃圾回收GC</title>
    <url>/2020/03/01/JAVA/</url>
    <content><![CDATA[<p><img src="/.com/2020/03//JAVA%E5%86%85%E5%AD%98.jpg" alt></p>
<h4 id="java内存机制"><a class="markdownIt-Anchor" href="#java内存机制"></a> JAVA内存机制</h4>
<blockquote>
<ul>
<li>私有内存区:伴随线程产生而产生 , 一旦线程终止, 私有内存区也会自动清除</li>
<li>程序计数器: 指示当前程序执行到了哪一行,执行Java方法时记录正在执行的虚拟机字节码指令地址; 执行本地方法时, 计数器值为NULL</li>
<li>虚拟机栈: 用于执行Java方法, 栈存储局部变量表, 操作数栈, 动态链接, 方法返回地址和一些额外的附加信息. 程序执行时入栈; 执行完成后栈帧出栈.</li>
<li>Java堆: Java虚拟机管理的内存最大的 一块, 所有线程共享, 几乎所有的对象实例和数组都在这里分配内存. <strong>GC主要就是在Java堆里进行</strong>.堆内存又分为: 新生代(新生代又分为 Eden80%, Survivor20%) 和老生代(Old) , 并且一般新生代的空间比老年代大.</li>
<li>方法区: 只有一个方法区共享. 实际也是堆,只是用于存储类, 常量相关的信息, 来存放程序中永远不变或唯一的内容(类信息[Class对象], 静态变量, 字符串常量等). 但是已经被最新的JVM取消了,现在,被加载的类作为元数据加载到底层操作系统的本地内存区.</li>
</ul>
</blockquote>
<h4 id="垃圾回收机制"><a class="markdownIt-Anchor" href="#垃圾回收机制"></a> 垃圾回收机制</h4>
<h6 id="gc的主要任务"><a class="markdownIt-Anchor" href="#gc的主要任务"></a> Gc的主要任务:</h6>
<ol>
<li>分配内存</li>
<li>确保被引用对象的内存不被错误的回收</li>
<li>回收不再被引用的对象的内存空间</li>
</ol>
<h6 id="垃圾回收机制的主要解决问题"><a class="markdownIt-Anchor" href="#垃圾回收机制的主要解决问题"></a> 垃圾回收机制的主要解决问题</h6>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<a id="more"></a>
<p><strong>针对问题1: 垃圾收集器会对堆进行回收前, 去确定对象中哪些是&quot;存活&quot; , 哪些是&quot; 死亡&quot; (不能再被任何途径使用的对象)</strong></p>
<p>判断:</p>
<ol>
<li>
<p>引用计数法</p>
<p>每当一个地方引用时, 计数器+1 ; 引用失效时, 计数器 -1; 计数值 =0  不可能再被引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例：</span></span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">        test1.obj = test2;</span><br><span class="line">        test2.obj = test1;</span><br><span class="line">        <span class="comment">//test1 ，test12能否被回收？</span></span><br><span class="line">        System.gc();</span><br></pre></td></tr></table></figure>
<p>查看运行结果，会发现并没有因为两个对象互相引用就没有回收，因此引用计数算法很难解决<strong>对象之间相互矛盾循环引用</strong>的问题。</p>
</li>
<li>
<p>可达性分析算法:</p>
<p>向图,树图, 把一系列&quot;GC Roots&quot; 作为起始点, 从节点向下搜索, 路径成为引用链, 当一个对象到 GC Roots没有任何引用链相连, 即不可达时, 则证明此对象是不可用的.</p>
<p>**Eg:**一颗树有很多丫枝，其中一个分支断了，跟树上没有任何联系，那就说明这个分支没有用了，就可以当垃圾回收去烧了。</p>
<p>**Tips:**在Java中可作为GCRoots的对象:</p>
<ol>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象;</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象.</li>
</ol>
</li>
</ol>
<h6 id><a class="markdownIt-Anchor" href="#"></a> </h6>
<p><strong>问题2   什么时候回收?</strong></p>
<p>即使是被判断不可达的对象, 也要再进行筛选, 当对象没有覆盖finalize()方法, 或者finaize()方法已经被虚拟机调用过, 则没有必要执行;</p>
<p>如果有必要执行:</p>
<ol>
<li>放置在F-Queue队列中</li>
<li>Finalizer线程执行</li>
</ol>
<p>**Tips:**对象可以在被GC时可以自我拯救（this），机会只有一次，因为任何一个对象的finalize() 方法都只会被系统自动调用一次。并不建议使用，应该避免。使用try_finaly或者其他方式。</p>
<p><strong>问题3  如何回收</strong></p>
<ol>
<li>
<p>标记.清除算法</p>
<p>两个阶段: 标记, 清除;</p>
<p>不足: 效率问题,空间问题(会产生大量不连续的内存碎片)</p>
</li>
<li>
<p>复制算法(新生代 )</p>
<p>将可用内存按容量分为大小相等的两块, 每次都只使用其中一块;</p>
<p>不足: 将内存缩小为了原来的一半</p>
</li>
<li>
<p>标记. 整理算法  (Old)</p>
<p>标记,清除(让存活的对象都像一端移动)</p>
</li>
</ol>
<p>垃圾回收的流程:</p>
<ol>
<li>新建的对象,大部分存储在Eden中</li>
<li>当Eden内存不够, 就进行Minor GC释放掉不活跃的对象存放到另一个Survivor中,(如Survivor1).</li>
<li>当Eden区再次满了, 将Survivor1中不能清空的内容放到Survivor2中,同时将Eden区.中的不能清空的对象, 复制到Survivor1, 同时清空Eden区</li>
<li>重复多次(默认15次) :Survivor中没有被清理的对象会复制到老年区(Old)</li>
<li>当Old达到一定比例就会触发Major GC释放老年代</li>
<li>当Old区满了, 则触发一个一次完整的垃圾回收(Full GC)</li>
<li>如果内存还是不够, JVM会抛出内存不足, 发生oom, 内存泄漏</li>
</ol>
<p><strong>默认比例:</strong></p>
<ol>
<li>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 );</li>
<li>新生代 Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )</li>
</ol>
<p><strong>补充1:</strong> 分代垃圾回收</p>
<blockquote>
<ul>
<li>Minor用于清理新生代(Eden)区域, Eden区满了就会触发一次Minor GC, 清理无用对象, 将有用对象复制到&quot;Survivor1&quot;, “Survivor2” 区中(这两个区，大小空间相同，同一时刻Survivor1和Survivor2只有一个在用一个为空).</li>
<li>Major GC: 用于清理老年代区域</li>
<li>Full GC: 用于清理新生代, 老年代区域, 成本较高, 会对系统性能产生影响.</li>
</ul>
</blockquote>
<p><strong>补充2:</strong></p>
<p>在对JVM调优的过程, 很大一部分工作就是对于Full GC 调节. 根据上述GC过程, 我们可以发现老年代被写满, System.gc()被现实调用, 上一次GC之后Heap的各域分配策略动态变化都可能导致Full GC.</p>
<p>开发中容易造成内存泄漏的操作:</p>
<blockquote>
<ul>
<li>创建大量无用的对象:比如需要大量连接字符串时,使用String而不是StringBulider/StringBuffer/线程池.</li>
<li>静态集合类的使用: HashMap, Vector , List</li>
<li>各种连接对象未及时释放关闭</li>
<li>监听器的使用</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
