<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>background</title>
    <url>/2020/03/07/background/</url>
    <content><![CDATA[<p>body {<br>
background:url(<a href="https://uploadbeta.com/api/pictures/random/?key=BingEveryday">https://uploadbeta.com/api/pictures/random/?key=BingEveryday</a>	WallpaperPicture);<br>
background-repeat: no-repeat;<br>
background-attachment: fixed;<br>
background-position: center;<br>
}</p>
<p>url : 指定链接</p>
<p>repeat: 重复问题</p>
<p>attachment: 是否移动</p>
<p>position: 出现位置</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>实现queue</title>
    <url>/2020/03/05/%E5%AE%9E%E7%8E%B0queue/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2020/03/04/%E5%90%88%E5%B9%B6%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>leecode 56</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目：给出一个区间的集合，请合并所有重叠的区间。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>
<p>首先对集合进行排序，intervals.sort( )按照每个数组的首个数字排序；</p>
</li>
<li>
<p>考虑前一区间、后一区间的重叠关系：“交叉”、“覆盖”</p>
</li>
<li>
<p>使用一临时区间temp记录合并后的左右端点，合并时更新temp的右端点即可。</p>
<a id="more"></a>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ve;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    f.push_back(<span class="number">1</span>);</span><br><span class="line">    f.push_back(<span class="number">3</span>);</span><br><span class="line">    ve.push_back(f);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g;</span><br><span class="line">    g.push_back(<span class="number">2</span>);</span><br><span class="line">    g.push_back(<span class="number">6</span>);</span><br><span class="line">    ve.push_back(g);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    h.push_back(<span class="number">8</span>);</span><br><span class="line">    h.push_back(<span class="number">10</span>);</span><br><span class="line">    ve.push_back(h);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; j;</span><br><span class="line">    j.push_back(<span class="number">15</span>);</span><br><span class="line">    j.push_back(<span class="number">18</span>);</span><br><span class="line">    ve.push_back(j);</span><br><span class="line">    sort(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">int</span> left=ve[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right=ve[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ve.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i][<span class="number">0</span>]&lt;=right)&#123;</span><br><span class="line">            right=<span class="built_in">max</span>(ve[i][<span class="number">1</span>],right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            q.push_back(left);</span><br><span class="line">            q.push_back(right);</span><br><span class="line">            v.push_back(q);</span><br><span class="line">            left=ve[i][<span class="number">0</span>];</span><br><span class="line">            right=ve[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">       s.push_back(left);</span><br><span class="line">       s.push_back(right);</span><br><span class="line">       v.push_back(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i][<span class="number">0</span>]&lt;&lt;<span class="string">","</span>&lt;&lt;v[i][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案1   排序后比较.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring题目</title>
    <url>/2020/03/03/Spring%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p><strong>AOP(面向切面编程)</strong></p>
<p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
<p>AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。</p>
<p>使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。</p>
<p>从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。</p>
<p>这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。</p>
<p>Spring的AOP的原理。</p>
<ol>
<li>AOP相关的概念</li>
</ol>
<p>1） <em>Aspect</em> ：切面，切入系统的一个切面。比如事务管理是一个切面，权限管理也是一个切面；</p>
<p>2） <em>Join point</em> ：连接点，也就是可以进行横向切入的位置；</p>
<p>3） <em>Advice</em> ：通知，切面在某个连接点执行的操作(分为: <em>Before advice</em> , <em>After returning advice</em> , <em>After throwing advice</em> , <em>After (finally) advice</em> , <em>Around advice</em> )；</p>
<p>4） <em>Pointcut</em> ：切点，符合切点表达式的连接点，也就是真正被切入的地方；</p>
<ol start="2">
<li>AOP 的实现原理</li>
</ol>
<p>AOP分为静态AOP和动态AOP。</p>
<p>静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。</p>
<p>动态AOP是指将切面代码进行动态织入实现的AOP。</p>
<p>Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术) 。尽管实现技术不一样，但 都是基于代理模式 ， 都是生成一个代理对象 。</p>
<a id="more"></a>
<h4 id="1-jdk动态代理"><a class="markdownIt-Anchor" href="#1-jdk动态代理"></a> 1) JDK动态代理</h4>
<p>主要使用到 InvocationHandler 接口和 Proxy.newProxyInstance() 方法。</p>
<p>JDK动态代理要求被代理实现一个接口，只有接口中的方法才能够被代理 。</p>
<p>其方法是将被代理对象注入到一个中间对象，而中间对象实现InvocationHandler接口，</p>
<p>在实现该接口时，可以在 被代理对象调用它的方法时，在调用的前后插入一些代码。</p>
<p>而 Proxy.newProxyInstance() 能够利用中间对象来生产代理对象。</p>
<p>插入的代码就是切面代码。所以使用JDK动态代理可以实现AOP。</p>
<p>我们看个例子：</p>
<p>被代理对象实现的接口，只有接口中的方法才能够被代理：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>UserService &#123;</span><br><span class="line">    public void addUser(User user);</span><br><span class="line">    public<span class="built_in"> User </span>getUser(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add user into database."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public<span class="built_in"> User </span>getUser(int id) &#123;</span><br><span class="line">       <span class="built_in"> User user </span>= new User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        System.out.println(<span class="string">"getUser from database."</span>);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理中间类：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result =  method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyUtil(Object <span class="keyword">target</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import net.aazj.pojo.User;</span><br><span class="line">public <span class="keyword">class</span> ProxyTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> <span class="constructor">UserServiceImpl()</span>;    <span class="comment">// 被代理的对象</span></span><br><span class="line">        ProxyUtil proxyUtils = <span class="keyword">new</span> <span class="constructor">ProxyUtil(<span class="params">proxyedObject</span>)</span>;</span><br><span class="line">        <span class="comment">// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()</span></span><br><span class="line">        UserService proxyObject = (UserService) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(Thread.<span class="params">currentThread</span>()</span>.get<span class="constructor">ContextClassLoader()</span>, </span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">UserServiceImpl</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Interfaces()</span>, proxyUtils);</span><br><span class="line">        proxyObject.get<span class="constructor">User(1)</span>;</span><br><span class="line">        proxyObject.add<span class="constructor">User(<span class="params">new</span> User()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">getUser <span class="keyword">from</span> database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="builtin-name">add</span><span class="built_in"> user </span>into database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">我们看到在 UserService接口中的方法 addUser 和 getUser方法的前面插入了我们自己的代码。这就是JDK动态代理实现AOP的原理。</span><br><span class="line"></span><br><span class="line">我们看到该方式有一个要求， 被代理的对象必须实现接口，而且只有接口中的方法才能被代理 。</span><br></pre></td></tr></table></figure>
<p>2）CGLIB （code generate libary）</p>
<p>字节码生成技术实现AOP，其实就是继承被代理对象，然后Override需要被代理的方法，在覆盖该方法时，自然是可以插入我们自己的代码的。</p>
<p>因为需要Override被代理对象的方法，所以自然CGLIB技术实现AOP时，就 必须要求需要被代理的方法不能是final方法，因为final方法不能被子类覆盖 。</p>
<p>我们使用CGLIB实现上面的例子：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.aazj.aop;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGProxy</span><span class="params">(Object <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do sth before...."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(arg0, arg2);</span><br><span class="line">        System.out.println(<span class="string">"do sth after...."</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.<span class="keyword">target</span>.getClass());    <span class="comment">// 设置父类</span></span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);    <span class="comment">// 在调用父类方法时，回调 this.intercept()</span></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> enhancer.<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        Object proxyedObject = <span class="keyword">new</span> <span class="type">UserServiceImpl</span>();    <span class="comment">// 被代理的对象</span></span><br><span class="line">        CGProxy cgProxy = <span class="keyword">new</span> <span class="type">CGProxy</span>(proxyedObject);</span><br><span class="line">        UserService proxyObject = (UserService) cgProxy.getProxyObject();</span><br><span class="line">        proxyObject.getUser(<span class="number">1</span>);</span><br><span class="line">        proxyObject.addUser(<span class="keyword">new</span> <span class="type">User</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">getUser <span class="keyword">from</span> database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="keyword">do</span> sth before<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="builtin-name">add</span><span class="built_in"> user </span>into database.</span><br><span class="line"><span class="keyword">do</span> sth after<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">我们看到达到了同样的效果。</span><br><span class="line">它的原理是生成一个父类 enhancer.setSuperclass( this.target.getClass()) 的子类 enhancer.create() ，然后对父类的方法进行拦截enhancer.setCallback( this) . </span><br><span class="line">对父类的方法进行覆盖，所以父类方法不能是final的。</span><br></pre></td></tr></table></figure>
<p>3） 接下来我们看下spring实现AOP的相关源码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="title">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport <span class="built_in">config</span>)</span> throws AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="built_in">config</span>.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(<span class="built_in">config</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码我们可以看到：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (targetClass.is<span class="constructor">Interface()</span>) &#123;</span><br><span class="line">                return <span class="keyword">new</span> <span class="constructor">JdkDynamicAopProxy(<span class="params">config</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="keyword">new</span> <span class="constructor">ObjenesisCglibAopProxy(<span class="params">config</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果被代理对象实现了接口，那么就使用JDK的动态代理技术，反之则使用CGLIB来实现AOP，所以 Spring默认是使用JDK的动态代理技术实现AOP的 。</p>
<p>JdkDynamicAopProxy的实现其实很简单：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final <span class="keyword">class</span> JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;    </span><br><span class="line">@Override</span><br><span class="line">public Object get<span class="constructor">Proxy(ClassLoader <span class="params">classLoader</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + this.advised.get<span class="constructor">TargetSource()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;<span class="literal">[]</span> proxiedInterfaces = <span class="module-access"><span class="module"><span class="identifier">AopProxyUtils</span>.</span></span>complete<span class="constructor">ProxiedInterfaces(<span class="params">this</span>.<span class="params">advised</span>)</span>;</span><br><span class="line">    find<span class="constructor">DefinedEqualsAndHashCodeMethods(<span class="params">proxiedInterfaces</span>)</span>;</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">classLoader</span>, <span class="params">proxiedInterfaces</span>, <span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\3. Spring AOP的配置</p>
<p>Spring中AOP的配置一般有两种方法，一种是使用 <a href="aop:config">aop:config</a> 标签在xml中进行配置，一种是使用注解以及@Aspect风格的配置。</p>
<p>1） 基于<a href="aop:config">aop:config</a>的AOP配置</p>
<p>下面是一个典型的事务AOP的配置：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;tx:advice id="transactionAdvice" <span class="keyword">transaction</span>-manager="transactionManager"?&gt;</span><br><span class="line">    &lt;tx:attributes &gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="add*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="append*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="insert*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="save*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="update*" propagation="REQUIRED" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="get*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="find*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="load*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="search*" propagation="SUPPORTS" /&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> <span class="type">name</span>="*" propagation="SUPPORTS" /&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id="transactionPointcut" expression="execution(* net.aazj.service..*Impl.*(..))" /&gt;</span><br><span class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>="transactionPointcut" advice-<span class="keyword">ref</span>="transactionAdvice" /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"aspectBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.aazj.aop.DataSourceInterceptor"</span>/&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect id=<span class="string">"dataSourceAspect"</span> ref=<span class="string">"aspectBean"</span>&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"dataSourcePoint"</span> expression=<span class="string">"execution(public * net.aazj.service..*.getUser(..))"</span> /&gt;</span><br><span class="line">        &lt;aop:pointcut expression=<span class="string">""</span> id=<span class="string">""</span>/&gt;</span><br><span class="line">        &lt;aop:before method=<span class="string">"before"</span> pointcut-ref=<span class="string">"dataSourcePoint"</span>/&gt;</span><br><span class="line">        &lt;aop:after method=<span class="string">""</span>/&gt;</span><br><span class="line">        &lt;aop:around method=<span class="string">""</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/aop:aspect&gt;</span></span><br><span class="line"><span class="regexp">    &lt;aop:aspect&gt;&lt;/</span>aop:aspect&gt;</span><br><span class="line">&lt;<span class="regexp">/aop:config&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="aop:aspect">aop:aspect</a> 配置一个切面；</p>
<p><a href="aop:pointcut">aop:pointcut</a>配置一个切点，基于切点表达式；</p>
<p><a href="aop:before">aop:before</a>,<a href="aop:after">aop:after</a>,<a href="aop:around">aop:around</a>是定义不同类型的advise. a</p>
<p>spectBean 是切面的处理bean：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInterceptor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        DataSourceTypeManager.<span class="built_in">set</span>(DataSources.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>基于注解和@Aspect风格的AOP配置</li>
</ol>
<p>我们以事务配置为例：首先我们启用基于注解的事务配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用annotation定义事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后扫描Service包：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"net.aazj.service,net.aazj.aop"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>最后在service上进行注解：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">Service(<span class="string">"userService"</span>)</span></span><br><span class="line">@Transactional</span><br><span class="line">public <span class="keyword">class</span> UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    @Transactional (readOnly=<span class="literal">true</span>)</span><br><span class="line">    public User get<span class="constructor">User(<span class="params">int</span> <span class="params">userId</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"in UserServiceImpl getUser"</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">DataSourceTypeManager</span>.</span></span>get<span class="literal">()</span>);</span><br><span class="line">        return userMapper.get<span class="constructor">User(<span class="params">userId</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add<span class="constructor">User(String <span class="params">username</span>)</span>&#123;</span><br><span class="line">        userMapper.add<span class="constructor">User(<span class="params">username</span>)</span>;</span><br><span class="line"><span class="comment">//        int i = 1/0;    // 测试事物的回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">    public void delete<span class="constructor">User(<span class="params">int</span> <span class="params">id</span>)</span>&#123;</span><br><span class="line">        userMapper.delete<span class="constructor">ByPrimaryKey(<span class="params">id</span>)</span>;</span><br><span class="line"><span class="comment">//        int i = 1/0;    // 测试事物的回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">    @Transactional (rollbackFor = <span class="module-access"><span class="module"><span class="identifier">BaseBusinessException</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">    public void add<span class="constructor">AndDeleteUser(String <span class="params">username</span>, <span class="params">int</span> <span class="params">id</span>)</span> throws BaseBusinessException&#123;</span><br><span class="line">        userMapper.add<span class="constructor">User(<span class="params">username</span>)</span>;</span><br><span class="line">        this.m1<span class="literal">()</span>;</span><br><span class="line">        userMapper.delete<span class="constructor">ByPrimaryKey(<span class="params">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> void m1<span class="literal">()</span> throws BaseBusinessException &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BaseBusinessException(<span class="string">"xxx"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="built_in">int</span> insert<span class="constructor">User(User <span class="params">user</span>)</span> &#123;</span><br><span class="line">        return this.userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定。这种事务配置方式，不需要我们书写pointcut表达式，而是我们在需要事务的类上进行注解。但是如果我们自己来写切面的代码时，还是要写pointcut表达式。下面看一个例子(自己写切面逻辑)：</p>
<p>首先去扫描 @Aspect 注解定义的 切面：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"net.aazj.aop"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>切面代码：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Before</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Pointcut</span>;</span><br><span class="line">import org.springframework.core.<span class="keyword">annotation</span>.<span class="title">Order</span>;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Aspect    /<span class="regexp">/ for aop</span></span><br><span class="line"><span class="regexp">@Component /</span><span class="regexp">/ for auto scan</span></span><br><span class="line"><span class="regexp">@Order(0)  /</span><span class="regexp">/ execute before @Transactional</span></span><br><span class="line"><span class="regexp">public class DataSourceInterceptor &#123;</span></span><br><span class="line"><span class="regexp">    @Pointcut("execution(public * net.aazj.service..*.get*(..))")</span></span><br><span class="line"><span class="regexp">    public void dataSourceSlave()&#123;&#125;;</span></span><br><span class="line"><span class="regexp">    @Before("dataSourceSlave()")</span></span><br><span class="line"><span class="regexp">    public void before(JoinPoint jp) &#123;</span></span><br><span class="line"><span class="regexp">        DataSourceTypeManager.set(DataSources.SLAVE);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们使用到了 @Aspect 来定义一个切面；</p>
<p>@Component是配合<a href="context:component-scan/">context:component-scan/</a>，不然扫描不到；</p>
<p>@Order定义了该切面切入的顺序 ，因为在同一个切点，可能同时存在多个切面，那么在这多个切面之间就存在一个执行顺序的问题。</p>
<p>该例子是一个切换数据源的切面，那么他应该在 事务处理 切面之前执行，所以我们使用 @Order(0) 来确保先切换数据源，然后加入事务处理。</p>
<p>@Order的参数越小，优先级越高，默认的优先级最低：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation that defines ordering. The value is optional, and represents order value</span></span><br><span class="line"><span class="comment"> * as defined in the &#123;@link Ordered&#125; interface. Lower values have higher priority.</span></span><br><span class="line"><span class="comment"> * The default value is &#123;@code Ordered.LOWEST_PRECEDENCE&#125;, indicating</span></span><br><span class="line"><span class="comment"> * lowest priority (losing to any other specified order value).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Order &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The order value. Default is &#123;@link Ordered#LOWEST_PRECEDENCE&#125;.</span></span><br><span class="line"><span class="comment">     * @see Ordered#getOrder()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">value</span>() <span class="selector-tag">default</span> <span class="selector-tag">Ordered</span><span class="selector-class">.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3） 切点表达式(pointcut)</p>
<p>上面我们看到，无论是 <a href="aop:config">aop:config</a> 风格的配置，还是 @Aspect 风格的配置，切点表达式都是重点。都是我们必须掌握的。</p>
<p>1&gt;pointcut语法形式(execution)：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">execution(modifiers-<span class="built_in">pattern</span>? ret-type-<span class="built_in">pattern</span> declaring-type-<span class="built_in">pattern</span>? name-<span class="built_in">pattern</span>(param-<span class="built_in">pattern</span>)throws-<span class="built_in">pattern</span>?)</span><br></pre></td></tr></table></figure>
<p>带有 ? 号的部分是可选的，所以可以简化成： ret-type-pattern name-pattern(param_pattern) 返回类型，方法名称，参数三部分来匹配 。</p>
<p>配置起来其实也很简单： * 表示任意返回类型，任意方法名，任意一个参数类型； … 连续两个点表示0个或多个包路径，还有0个或多个参数 。就是这么简单。看下例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">execution</span>(* <span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span>..*<span class="selector-class">.get</span>*(..)) ：表示<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span>包或者子包下的以<span class="selector-tag">get</span>开头的方法，参数可以是0个或者多个（参数不限）；</span><br><span class="line"><span class="selector-tag">execution</span>(* <span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.AccountService</span>.*(..)): 表示<span class="selector-tag">AccountService</span>接口下的任何方法，参数不限；</span><br><span class="line">注意这里，将类名和包路径是一起来处理的，并没有进行区分，因为类名也是包路径的一部分。</span><br><span class="line">参数<span class="selector-tag">param-</span> <span class="selector-tag">pattern</span> 部分比较复杂： () 表示没有参数，(..)参数不限，(*,<span class="selector-tag">String</span>) 第一个参数不限类型，第二参数为<span class="selector-tag">String</span> .</span><br></pre></td></tr></table></figure>
<p>2&gt;within() 语法:</p>
<p>within()只能指定(限定)包路径(类名也可以看做是包路径)，表示某个包下或者子报下的所有方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(net.aazj.service.*)</span></span>， within(net<span class="selector-class">.aazj</span><span class="selector-class">.service</span>..*)，within(net<span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserServiceImpl</span>.*)</span><br></pre></td></tr></table></figure>
<p>3&gt;this() 与 target():</p>
<p>this是指代理对象，target是指被代理对象(目标对象)。所以 this() 和 target() 分别限定 代理对象的类型和被代理对象的类型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">this</span>(<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserService</span>): 实现了<span class="selector-tag">UserService</span>的代理对象(中的所有方法)； </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">target</span> (<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.service</span><span class="selector-class">.UserService</span>): 被代理对象 实现了<span class="selector-tag">UserService</span>(中的所有方法)；</span><br></pre></td></tr></table></figure>
<p>4&gt; <em>args():</em></p>
<p>限定方法的参数的类型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">args</span>(<span class="selector-tag">net</span><span class="selector-class">.aazj</span><span class="selector-class">.pojo</span><span class="selector-class">.User</span>): 参数为<span class="selector-tag">User</span>类型的方法。</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>&gt;@target(), @within(), @<span class="keyword">annotation</span>(), @<span class="title">args</span>():</span><br><span class="line"></span><br><span class="line">这些语法形式都是针对注解的 ，比如 带有某个注解的 类 ， 带有某个注解的 方法， 参数的类型 带有某个注解 ：</span><br><span class="line">@within(org.springframework.transaction.<span class="keyword">annotation</span>.<span class="title">Transactional</span>) </span><br><span class="line">@target(org.springframework.transaction.<span class="keyword">annotation</span>.<span class="title">Transactional</span>)</span><br></pre></td></tr></table></figure>
<p>两者都是指被代理对象 类 上有 @Transactional 注解的(类的所有方法)，（两者似乎没有区别？？？）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@annotation</span>(org.springframework.transaction.annotation.Transactional)：  方法 带有 <span class="variable">@Transactional</span> 注解的所有方法 </span><br><span class="line"></span><br><span class="line"><span class="variable">@args</span>(org.springframework.transaction.annotation.Transactional)： 参数的类型 带有 <span class="variable">@Transactional</span> 注解 的所有方法</span><br></pre></td></tr></table></figure>
<p>6&gt;bean(): 指定某个bean的名称</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bean(userService)</span>: bean的id为 "userService" 的所有方法;</span><br><span class="line"></span><br><span class="line"><span class="attribute">bean(*Service)</span>: bean的id为 "Service"字符串结尾的所有方法;</span><br><span class="line"></span><br><span class="line">另外注意上面这些表达式是可以利用 ||, &amp;&amp;, ! 进行自由组合的。比如：execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(Integer,..)</span><br></pre></td></tr></table></figure>
<p>\4. 向注解处理方法传递参数</p>
<p>有时我们在写注解处理方法时，需要访问被拦截的方法的参数。此时我们可以使用 args() 来传递参数，下面看一个例子：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component // <span class="keyword">for</span> auto scan</span><br><span class="line">//@<span class="keyword">Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LogInterceptor &#123;    </span><br><span class="line">    @Pointcut("execution(public * net.aazj.service..*.getUser(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> myMethod()&#123;&#125;;</span><br><span class="line">    @<span class="keyword">Before</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">before</span>() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method start");</span><br><span class="line">    &#125; </span><br><span class="line">    @<span class="keyword">After</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">after</span>() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method after");</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterReturning("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> AfterReturning() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method AfterReturning");</span><br><span class="line">    &#125; </span><br><span class="line">    @AfterThrowing("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">//  @Around("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> AfterThrowing() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method AfterThrowing");</span><br><span class="line">    &#125; </span><br><span class="line">    @Around("execution(public * net.aazj.mapper..*.*(..))")</span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">Object</span> Around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method Around");</span><br><span class="line">        SourceLocation sl = jp.getSourceLocation();</span><br><span class="line">        <span class="keyword">Object</span> ret = jp.proceed();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getTarget());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">    @<span class="keyword">Before</span>("execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before3(<span class="type">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId-----" + userId);</span><br><span class="line">    &#125;  </span><br><span class="line">    @<span class="keyword">Before</span>("myMethod()")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before2(JoinPoint jp) &#123;</span><br><span class="line">        <span class="keyword">Object</span>[] args = jp.getArgs();</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId11111: " + (<span class="type">Integer</span>)args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getTarget());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getThis());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(jp.getSignature());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("method start");</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">Before</span>("execution(public * net.aazj.service..*.getUser(..)) &amp;&amp; args(userId,..)")</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> before3(<span class="type">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("userId-----" + userId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它会拦截 net.aazj.service 包下或者子包下的getUser方法，并且该方法的第一个参数必须是int型的， 那么使用切点表达式args(userId,…) 就可以使我们在切面中的处理方法before3中可以访问这个参数。</p>
<p>before2方法也让我们知道也可以通过 JoinPoint 参数来获得被拦截方法的参数数组。 JoinPoint 是每一个切面处理方法都具有的参数， @Around 类型的具有的参数类型为ProceedingJoinPoint。通过 JoinPoint或者 ProceedingJoinPoint 参数可以访问到被拦截对象的一些信息(参见上面的 before2 方法)。</p>
<ol>
<li>
<p>请简述 Spring 框架的优点。</p>
<blockquote>
<p>**非侵入式设计:**Spring是一种非侵入式（non-invasive）框架，它可以使应用程序代码对框架的依赖最小化。</p>
</blockquote>
<blockquote>
<p>**方便解耦、简化开发:**Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护工作都交给Spring容器的管理，大大的降低了组件之间的耦合性。</p>
</blockquote>
<blockquote>
<p>**支持AOP:**Spring提供了对AOP的支持，它允许将一些通用任务，如安全、事物、日志等进行集中式处理，从而提高了程序的复用性。</p>
</blockquote>
<blockquote>
<p><strong>支持声明式事务处理</strong></p>
<p>只需要通过配置就可以完成对事物的管理，而无须手动编程。</p>
</blockquote>
<blockquote>
<p><strong>方便程序的测试</strong></p>
<p>Spring提供了对Junit4的支持，可以通过注解方便的测试Spring程序。</p>
</blockquote>
<blockquote>
<p><strong>方便集成各种优秀框架</strong></p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如Struts、Hibernate、MyBatis、Quartz等）的直接支持。</p>
</blockquote>
<blockquote>
<p><strong>降低Jave EE API的使用难度。</strong></p>
<p>Spring对Java EE开发中非常难用的一些API（如JDBC、JavaMail等），都提供了封装，使这些API应用难度大大降低。</p>
</blockquote>
</li>
<li>
<p>请简述什么是 Spring 的 loC 和DI。</p>
<blockquote>
<h4 id="ioc控制反转"><a class="markdownIt-Anchor" href="#ioc控制反转"></a> IOC（控制反转）</h4>
<p>传统的Java开发过程中，当需要一个对象的时候，我们需要自己new或者getInstance等直接或间接调用构造方法创建一个对象；而在Spring容器中，Spring容器利用 工厂模式(BeanFactory)为我们创建了所需要的对象，使用时无须自己创建，直接调用Spring为我们创建的对象即可，这就是控制反转的思想。</p>
<p><strong>优点</strong>：简化了我们对对象的管理，交给了Spring管理；程序员不用再自己创建对象，需要时直接从Spring中取。由主动创建对象变成了被动接收对象，控制权反转，减轻了程序员的代码量，提高了开发效率。打个比方：IOC就像现在得订餐APP，以前我们吃饭需要自己去做，去New一顿饭出来；现在我们有了订餐APP(Spring)，我们只需要登录这个APP，在APP订餐页面<code>spring.xml</code>(Spring配置文件)填写你想吃的饭(也就是Bean对象)，然后就可以预定你要吃的饭，想要猪头肉就会给你送猪头肉，想要红烧肉就会送红烧肉；各种菜就像是Property，这样我们坐在家中就可以吃到饭了，不用自己再动手去做了。</p>
</blockquote>
<blockquote>
<p><strong>DI(依赖注入)</strong></p>
<p>Spring为我们提供了三种注入方式：<a href="https://www.cnblogs.com/xiaoxi/p/5865330.html"><strong>Setter注入</strong>、<strong>构造方法注入</strong>、<strong>接口注入</strong></a></p>
<p>Spring使用JavaBean对象的Set方法或者带参数的构造方法为我们创建所需要的对象时将其属性自动设置为所需要的值的过程就是依赖注入的思想。</p>
<p><strong>优点</strong>：有了Spring容器，当我们想要创建一个Service时，就可以直接从Spring容器中拿；或者想在Service中调用Dao也不需要在Service里创建，因为Spring会从容器中取出Dao，并注入到Service里，也就是依赖注入。</p>
</blockquote>
<blockquote>
<h4 id="aop面向切面编程"><a class="markdownIt-Anchor" href="#aop面向切面编程"></a> AOP（面向切面编程）</h4>
<p>在面向对象编程(OOP)中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如：权限验证，事务管理，记录日志等公用操作处理的过程就是面向切面编程的思想。</p>
</blockquote>
</li>
<li>
<p>请简述 Bean 的生命周期。</p>
</li>
</ol>
<blockquote>
<ol>
<li>实例化bean对象(通过构造方法或者工厂方法)</li>
<li>设置对象属性(setter等)（依赖注入）</li>
<li>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）</li>
<li>如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</li>
<li>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法</li>
<li>调用Bean的初始化方法</li>
<li>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</li>
<li>使用Bean</li>
<li>容器关闭之前，调用Bean的销毁方法</li>
</ol>
</blockquote>
<ol start="4">
<li>
<p>请简述 Bean 的几种装配方式的基本用法。</p>
<blockquote>
<p><strong>1基于XML的装配</strong><br>
基于XML的装配，Spring提供了两种装配方式：设值注入（Setter Injection）和构造注入（Constructor Injection）。<br>
设值注入要求Bean必须满足一下要求：<br>
（1）Bean类必须提供一个默认的无参构造方法；<br>
（2）Bean类必须为需要注入的属性提供对应的setter方法；<br>
设值注入时，需要Spring在配置文件中，需要使用元素的子元素来为每个属性注入值；<br>
使用构造方法时，在配置文件里，需要使用元素的子元素来定义构造方法的参数，可以使用value属性（或者子元素）来设值该参数的值。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">见第二章代码  <span class="selector-tag">beans5</span><span class="selector-class">.xml</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2基于Annotation的装配</strong><br>
在实际应用中如果有很多Bean时，还通过使用XML配置会导致臃肿，给后续的维护和升级带来一定的困难。Spring提供了对Annotation注解技术的全面支持，可以解决此困难。</p>
</blockquote>
<p>Spring常用注解如下：</p>
<table>
<thead>
<tr>
<th><strong>Component</strong></th>
<th><strong>描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次；</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Repository</td>
<td>用于将数据访问层（DAO）层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Service</td>
<td>作用在业务层（service层），用于将业务层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Controller</td>
<td>作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean</td>
</tr>
<tr>
<td>Autowired</td>
<td>用于对Bean的属性变量、属性setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作</td>
</tr>
<tr>
<td>Resourse</td>
<td>作用与Autowired一样。Resourse两个重要的属性：name和type。Spring将name解析为Bean实例名称，type解析为Bean实例类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>3自动装配</strong><br>
自动装配，就是将一个bean自动地注入到其他Bean的property中。<br>
仿造如上示例二代码，在ServiceImpl.java和UserController.java中加入属性的Setter方法。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBean</title>
    <url>/2020/03/03/StringBean/</url>
    <content><![CDATA[<h3 id="1bean"><a class="markdownIt-Anchor" href="#1bean"></a> 1.Bean</h3>
<p>​		Spring 可以被看作是一个大型工厂，这个工厂的作用就是生产和管理 Spring 容器中的 Bean。 如果想要在项目中使用这个工厂，就需要开发者对 Spring 的配置文件进行配置。 Spring 容器支持 XML 和 Properties 两种格式的配置文件，在实际开发中，最常使用的就是 XML 格式的配置方式。这种配置方式通过 XML 文件来注册并管理 Bean 之间的依赖关系。 接下 来本小节将使用 XML 文件的形式对 Bean 的属性和定义进行详细的讲解。 在 Spring 中， XML 配置文件的根元素是<beans> ， <beans>中包含了多个<bean>子元素， 每一个<bean>子元素定义了一个 Bean ，并描述了该 Bean 如何被装配到 Spring 容器中。</bean></bean></beans></beans></p>
<p><bean>元素中同样包含了多个属性以及子元素</bean></p>
<a id="more"></a>
<!--more-->
<table>
<thead>
<tr>
<th>属性或子元素名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>是一个 Bean 的唯一标识符， Spring 窑器对 Bean 的配置、 筐理部通过该属性来完成</td>
</tr>
<tr>
<td>name</td>
<td>Spring 窑器同样可以通过此属性对容器中的 Bean 进行配置和管理， name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td>
</tr>
<tr>
<td>class</td>
<td>该属性指定了 Bean 的具体实现类， E必须是一个完整的类毡，使用类的全限定名</td>
</tr>
<tr>
<td>scope</td>
<td>用来设定 Bean 实例的作用域，莫属性值有: singleton( 单例)、 prototype( 原型)、 request、 sesslon、 global Session , application 和 websocket. 真默认值为 singleton</td>
</tr>
<tr>
<td>constructor-arg</td>
<td><bean>元素的子元素，可以使用此元素传入构造参数进行实例化。 该元素的 index 属性指 定构造参数的序号(从 O 开始) , type 属性指定构造参数的类型，参数值可以通过 ref 属性 或 value 属性直接指定，也可以通过 ref 或 value 子元素指定</bean></td>
</tr>
<tr>
<td>property</td>
<td><bean>元素的子元素， 用于调用 Bean 实例中的 setter 方法完成属性赋值，从而完成依赖注入。 该元素的 name 属性指定 Bean 实例中的相应属性毡 ref 属性或 value 属性用于 指定参数值</bean></td>
</tr>
<tr>
<td>ref</td>
<td><property>、 <constructor-arg>等元素的属性或子元素，可以用于指定对 Bean 工厂中 某个 Bean 实例的引用</constructor-arg></property></td>
</tr>
<tr>
<td>value</td>
<td><property>、 <constructor-arg>等元素的属性或子元素，可以用于直接指定一个常量值</constructor-arg></property></td>
</tr>
<tr>
<td>list</td>
<td>用于封装List 或数组类型的依赖注入</td>
</tr>
<tr>
<td>set</td>
<td>用于封装 Set 类型属性的依赖注入</td>
</tr>
<tr>
<td>map</td>
<td>用于封装 Map 类型属性的依赖注入</td>
</tr>
<tr>
<td>entry</td>
<td><map>元素的子元素，用于设置一个键值对。 真 key 属性指定字符串类型的键值， ref 或 value 子元素指定真僵，也可以通过 value-ref 或 value 属性指定真值</map></td>
</tr>
</tbody>
</table>
<p>如果在 Bean 中未指定 id 和 nam巳， 则 Spri吨会将c1ass值当作 id 使用。</p>
<h4 id="静态工厂方式实例化"><a class="markdownIt-Anchor" href="#静态工厂方式实例化"></a> 静态工厂方式实例化</h4>
<p>使用静态工厂是实例化 Bean 的另一种方式。 该方式要求开发者创建一个静态工厂的方法来 创建 Bean 的实例，其 Bean 配置中的 class 属性所指定的不再是 Bean 实例的实现类，而是静 态工厂类，同时还需要使用 factory-method 属性来指定所创建的静态工厂方法。 下面通过一个 案例来演示如何使用静态工厂方式实例化 Bean。</p>
<h4 id="实例工厂方式实例化"><a class="markdownIt-Anchor" href="#实例工厂方式实例化"></a> 实例工厂方式实例化</h4>
<p>还有一种实例化 Bean 的方式就是采用实例工厂。 此种方式的工厂类中，不再使用静态方法 创建 Bean 实例，而是采用直接创建 Bean 实例的方式。 同时，在配置文件中，需要实例化的 Bean 也不是通过 class 属性直接指向的实例化类，而是通过 factory- bean 属性指向配置的实例工厂， 然后使用 factory- method 属性确定使用工厂中的哪个方法。 下面通过一个案例来演示实例工厂 方式的使用。</p>
<h3 id="2bean的作用域"><a class="markdownIt-Anchor" href="#2bean的作用域"></a> 2.Bean的作用域</h3>
<table>
<thead>
<tr>
<th>作用域名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton(单例)</td>
<td>使用 singleton 定义的 Bean 在 Spring 窑器中将只有一个实例， 也就是说，无论有多少个 Bean 引用巴，始终将指向罔一个对象。 这也是 Spring 窑器默认的作用域</td>
</tr>
<tr>
<td>prototype (原型)</td>
<td>每次通过 Spring 窑器获取的 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例</td>
</tr>
<tr>
<td>request</td>
<td>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。 对不同的 HTTP 请求则会产生一个新的 Bean ，而且该 Bean 仅在当前 HTTP Request 内奇效</td>
</tr>
<tr>
<td>sesslon</td>
<td>在 一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。 对不同的 HTTPi需求则会产 生一个新的 Bean ，而且该 Bean 仅在当前 HTTP Sessio门内奇效</td>
</tr>
<tr>
<td>globalSession</td>
<td>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。 仅在使用 portlet 上下 文时有效</td>
</tr>
<tr>
<td>application</td>
<td>为每个 ServletContext 对象创建一个实例。 仅在 Web 相关的 ApplicationContext 中生效</td>
</tr>
<tr>
<td>websocket</td>
<td>为每个 websocket 对象创建一个实例。 仅在 Web 徊关的 ApplicationContext 中生效</td>
</tr>
</tbody>
</table>
<h4 id="1-singeton作用域"><a class="markdownIt-Anchor" href="#1-singeton作用域"></a> 1. singeton作用域</h4>
<p>singleton 是 Spring 容器默认的作用域，当 Bean 的作用域为 singleton 肘， Spring 容器就 只会存在一个共享的 Bean 实例，并且所有对 Bean 的请求，只要 id 与该 Bean 的 id 属性相匹配， 就会返回同一个 Bean 实例。 singleton 作用域对于无会话状态的 Bean (如 Dao 组件、 Service 组件)来说，是最理想的选择。</p>
<p>需要注意的是，如果不设置 scope=划ngleton&quot; ，其输出结果也是一个实例，因为 Spring 容 器默认的作用域就是 singleton。</p>
<h4 id="2-prototype作用域"><a class="markdownIt-Anchor" href="#2-prototype作用域"></a> 2. prototype作用域</h4>
<p>对需要保持会话状态的 Bean (如 Struts2 的 Action 类)应该使用 prototype 作用域。 在使 用 prototype 作用域时， Spring 容器会为每个对该 Bean 的请求都创建一个新的实例。</p>
<h4 id="3bean的生命周期"><a class="markdownIt-Anchor" href="#3bean的生命周期"></a> 3.Bean的生命周期</h4>
<p>(1)根据配置情况调用 Bean 构造方法或工厂方法实例化 Beano</p>
<p>(2)利用依赖注入完成 Bean 中所有属性值的配置注入。</p>
<p>(3)如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanNameO方 法传入当前 Bean 的 id 值。</p>
<p>(4)如果 Bean 实现了 BeanFactory Aware 接口，则 Spring 调用 setBeanFactoryO方法传 入当前工厂实例的引用。</p>
<p>(5)如果 Bean 实现了 ApplicationContextAware 接口，贝IJ Spring 调用 setApplicationContextO 方法传入当前 ApplicationContext 实例的引用。</p>
<p>(6 )如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforel n itialzationO对 Bean 进行加工操作，这个非常重要， Spring 的 AOP 就是用 它实现的。</p>
<p>(7 )如果 Bean 另见了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet()方法。<br>
(8 )如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。 (9 )如果有 BeanPostProcessor 和 Bean 关联，贝IJ Spring 将调用该接口的初始化方法 post ProcessAfterlnitialization()。 此时， Bean 已经可以被应用系统使用了。</p>
<p>(10 )如果在<bean> 中指定了该 Bean 的作用范围为 scope=“singleton” ，则将该 Bean 放 入 Spring loC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理;如果在<bean>中指定了 该 Bean 的作用范围为 scope=“prototype” ，贝IJ将该 Bean 交给调用者，调用者管理该 Bean 的生 命周期， Spring 不再管理该 Bean。</bean></bean></p>
<p>(11)如果 Bean 实现了 DisposableBean 接口，贝IJ Spring 会调用 destory()方法将 Spring 中的 Bean 销毁;如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法进行销毁。</p>
<p>Spring 为 Bean 提供了细致全面的生命周期过程，通过实现特定的接口或通过<bean>的属 性设置，都可以对 Bean 的生命周期过程产生影响。 我们可以随意地配置<bean>的属性，但是 在这里建议不要过多地使用 Bean 实现接口，因为这样会使代码和 Spring 聚合比较紧密。</bean></bean></p>
<h3 id="3bean的装配方式"><a class="markdownIt-Anchor" href="#3bean的装配方式"></a> 3.Bean的装配方式</h3>
<h4 id="1基于xml"><a class="markdownIt-Anchor" href="#1基于xml"></a> 1.基于xml</h4>
<p>Spring 提供了两种基于 XML 的装配方式:设值注入( Setter Injection )和构造注入 ( Constructor Injection )。 下面就讲解下如何在 XML 配置文件中使用这两种注入方式来实现基于 XML 的装配。</p>
<p>在 Spring 实例化 Bean 的过程中， Spring 首先会调用 Bean 的默认构造方法来实例化 Bean 对象，然后通过反射的方式调用 setter 方法来注入属性值。 因此，设值注入要求一个 Bean 必须 满足以下两点要求。</p>
<p>• Bean 类必须提供一个默认的无参构造方法。</p>
<p>• Bean 类必须为需要注入的属性提供对应的 setter 方法。</p>
<p>使用设值注入时，在 Spring 配置文件中，需要使用<bean>元素的子元素<property>来为每 个属性注入值;而使用构造注入时，在配置文件里，需要使用 <bean> 元素的子元素 &lt;constructor -arg&gt;来定义构造方法的参数，可以使用其 value 属性(或子元素)来设置该参数 的值。 下面通过一个案例来演示基于 XML 方式的 Bean 的装配。</bean></property></bean></p>
<h4 id="2基于annotation装配"><a class="markdownIt-Anchor" href="#2基于annotation装配"></a> 2.基于Annotation装配</h4>
<p>在 Spring 中，尽管使用 XML配置文件可以实现 Bean 的装配工作，但如果应用中有很多 Bean 时，会导致 XML 配置文件过于靡肿，给后续的维护和升级工作带来一定的困难。 为此， Spring 提供了对 Annotation (注解)技术的全面支持。 Spring 中定义了一系列的注解，常用的注解如下所示。</p>
<p>• @Component: 可以使用此注解描述 Spring 中的 Bean ，但它是一个泛化的概念，仅仅表 示一个组件 (Bean l，并且可以作用在任何层次。 使用时只需将该注解标注在相应类上即可。</p>
<p>• @Repository: 用于将数据访问层( DAO 层)的类标识为 Spring 中的 Bean ，其功能与 @Component 相同。</p>
<p>• @Service: 通常作用在业务层( Service 层 l，用于将业务层的类标识为 Spring 中的 Bean ， 其功能与@Component 相同。</p>
<p>• @Controller: 通常作用在控制层(如 Spring MVC 的 Controller l，用于将控制层的类标识 为 Spring 中的 Bean ，其功能与@Component 相同。</p>
<p>• @Autowired: 用于对 Bean 的属性变量、属性的 setter 方法及构造方法进行标注，配合对 应的注解处理器完成 Bean 的自动配置工作。 默认按照 Bean 的类型进行装配。</p>
<p>• @Resource: 其作用与 Autowired 一样。 其区别在于@Autowired 默认按照 Bean 类型装 配，而@Resource 默认按照 Bean 实例名称进行装配。 @Resource 中有两个重要属性: name 和 typeo Spring 将 name 属性解析为 Bean 实例名称， type 属性解析为 Bean 实例类型。 如果 指定 name 属性，贝IJ按实例名称进行装配;如果指定 type 属性，则按 Bean 类型进行装配;如 果都不指定，则先按 Bean 实例名称装配，如果不能匹配，再按照 Bean 类型进行装自己;如果都 无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</p>
<p>• @Qualifier: 与@Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为接 Bean 的实例名称装配， Bean 的实例名称由@Qualifier 注解的参数指定。</p>
<p>在上面几个注解中，虽然@Repository、 @Service 与@Controller 功能与@Component 注解 的功能相同，但为了使标注类本身用途更加清晰，建议在实际开发中使用@Repository、 @Service 与@Controller 分别对实现类进行标注。</p>
<h4 id="3自动装配"><a class="markdownIt-Anchor" href="#3自动装配"></a> 3.自动装配</h4>
<p>虽然使用注解的方式装配 Bean ，在一定程度上减少了配置文件中的代码量，但是也有企业项目中， 是没有使用注解方式开发的，那么有没有什么办法既可以减少代码量，又能够实现 Bean 的装配呢?</p>
<p>答案是肯定的， Spring 的 <bean>元素中包含一个 autowire 属性，我们可以通过设置 autowire 的属性值来自动装配 Bean。 所谓自动装配，就是将一个 Bean 自动地注入到其他 Bean 的 Property 中。</bean></p>
<p><bean>元素的 autowire 属性值及说明</bean></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>由 <bean> 的上级标签 <beans> 的 default-autowire 属 性值确定 。 例如 <beans defaultautowire="byName"> ，则该<bean>元素中的 autowire 属性对应的属性值就为 byName</bean></beans></beans></bean></td>
</tr>
<tr>
<td>byName</td>
<td>根据属性的名称自动装配。 窑器将根据名称查找与属性完全一致的 Bean ，并将真属性自动装配</td>
</tr>
<tr>
<td>byType</td>
<td>根据属性的数据类型 (Type) 自动装配，如果一个 Bean 的数据类型，兼容另一个 Bean 中属性的 数据类型，则自动装配</td>
</tr>
<tr>
<td>constructor</td>
<td>根据何造函数参数的数据类型，进行 byType 模式的自动装配</td>
</tr>
<tr>
<td>no</td>
<td>在默认情况下，不使用自动装配， Bean 依赖必须通过 ref 元素定义</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
      <tags>
        <tag>犯过的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性</title>
    <url>/2020/03/03/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>jdk1.8新特性主要:</p>
<blockquote>
<ul>
<li><strong>Lambda表达式</strong></li>
<li><strong>函数式接口</strong></li>
<li><strong>方法引用和构造器调用</strong></li>
<li><strong>Stream API</strong></li>
<li><strong>接口中的默认方法和静态方法</strong></li>
<li><strong>新时间日期API</strong></li>
</ul>
</blockquote>
<h2 id="一-lambda表达式"><a class="markdownIt-Anchor" href="#一-lambda表达式"></a> 一   Lambda表达式</h2>
<blockquote>
<p>lambda表达式本质上是一段匿名内部类, 也可以是一段可以传递的代码</p>
</blockquote>
<p>lambda最直观的优点:  简洁代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"========================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure>
<p>​		这样一个场景，在商城浏览商品信息时，经常会有条件的进行筛选浏览，例如要选颜色为红色的、价格小于8000千的….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选颜色为红色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Product&gt; <span class="title">filterProductByColor</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Product product : list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"红色"</span>.equals(product.getColor()))&#123;</span><br><span class="line">            prods.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prods;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选价格小于8千的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Product&gt; <span class="title">filterProductByPrice</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Product product : list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (product.getPrice() &lt; <span class="number">8000</span>)&#123;</span><br><span class="line">            prods.add(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prods;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对这个场景进行优化</p>
<p>**优化一: **使用设计模式</p>
<p>定义一个MyPredicate接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>MyPredicate &lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要筛选颜色为红色的商品,定义一个颜色过滤类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPredicate</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span> &lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RED = <span class="string">"红色"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> RED.equals(product.getColor());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>定义过滤方法，将过滤接口当做参数传入，这样这个过滤方法就不用修改，在实际调用的时候将具体的实现类传入即可。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;Product&gt; filterProductByPredicate(<span class="built_in">List</span>&lt;Product&gt; <span class="built_in">list</span>,MyPredicate&lt;Product&gt; mp)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;Product&gt; prods = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        for (Product prod : <span class="built_in">list</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>例如，如果想要筛选价格小于8000的商品，那么新建一个价格过滤类既可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">PricePredicate</span> <span class="symbol">implements</span> <span class="symbol">MyPredicate</span>&lt;<span class="symbol">Product</span>&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean test(Product product) &#123;</span><br><span class="line">        <span class="keyword">return</span> product.getPrice() &lt; <span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实现的话，每次变更需求都需要新建一个实现类，感觉还是有点繁琐，那么再来优化一下</p>
<p>**优化二:**使用匿名内部类</p>
<p>定义过滤方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">filterProductByPredicate</span><span class="params">(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp)</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Product prod : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用过滤方法时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按价格过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filterProductByPredicate(proList, <span class="keyword">new</span> MyPredicate&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> product.getPrice() &lt; <span class="number">8000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 按颜色过滤</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     filterProductByPredicate(proList, <span class="keyword">new</span> MyPredicate&lt;Product&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"红色"</span>.equals(product.getColor());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用匿名内部类, 就不需要每次都新建一个实现类, 直接在方法内部实现. 看到匿名内部类, 不禁想起了Lambda表达式.</p>
<p>**优化三:**使用Lambda表达式</p>
<p>定义过滤方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">filterProductByPredicate</span><span class="params">(List&lt;Product&gt; list,MyPredicate&lt;Product&gt; mp)</span></span>&#123;</span><br><span class="line">        List&lt;Product&gt; prods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Product prod : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.test(prod))&#123;</span><br><span class="line">                prods.add(prod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用lambda表达式进行过滤</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="literal">void</span> test4()&#123;</span><br><span class="line">      List&lt;Product&gt; products = filterProductByPredicate<span class="function"><span class="params">(proList, (p) -&gt; p.getPrice() &lt; <span class="number">8000</span>)</span>;</span></span><br><span class="line"><span class="function">      <span class="title">for</span> <span class="params">(Product pro : products)</span>&#123;</span></span><br><span class="line"><span class="function">          <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(pro)</span>;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>在jdk1.8中还有更加简便的操作 Stream API</p>
<p>**优化四:**使用Stream API</p>
<p>可以不用定义过滤方法,直接在集合上进行操作</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">// 使用jdk1.8中的Stream API进行集合的操作</span></span><br><span class="line"><span class="regexp">@Test</span></span><br><span class="line"><span class="regexp">public void test()&#123;</span></span><br><span class="line"><span class="regexp">    //</span> 根据价格过滤</span><br><span class="line">    proList.stream()</span><br><span class="line">           .fliter<span class="function"><span class="params">((p) -&gt; p.getPrice() &lt;<span class="number">8000</span>)</span></span></span><br><span class="line"><span class="function">           .<span class="title">limit</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 根据颜色过滤</span></span><br><span class="line"><span class="function">    <span class="title">proList</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           .<span class="title">fliter</span><span class="params">((p) -&gt; <span class="string">"红色"</span>.equals(p.getColor()))</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 遍历输出商品名称</span></span><br><span class="line"><span class="function">    <span class="title">proList</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           .<span class="title">map</span><span class="params">(Product::getName)</span></span></span><br><span class="line"><span class="function">           .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Lmabda表达式的语法总结： () -&gt; ();</p>
<table>
<thead>
<tr>
<th style="text-align:center">前置</th>
<th style="text-align:center">语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无参数无返回值</td>
<td style="text-align:center">()-&gt;System.out.println(“hello”)</td>
</tr>
<tr>
<td style="text-align:center">有一个参数无返回值</td>
<td style="text-align:center">(x)-&gt;System.out.println(x)</td>
</tr>
<tr>
<td style="text-align:center">有且只有一个参数无返回值</td>
<td style="text-align:center">x-&gt;System.out.println(x)</td>
</tr>
<tr>
<td style="text-align:center">有多个参数,有返回值,有多条lambda体语句</td>
<td style="text-align:center">(x,y) -&gt; {System.out.println(“xx”);return xx;};</td>
</tr>
<tr>
<td style="text-align:center">有多个参数,有返回值,只有一条lambda体语句</td>
<td style="text-align:center">(x,y)-&gt; xxxx</td>
</tr>
</tbody>
</table>
<p>口诀：左右遇一省括号，左侧推断类型省</p>
<p>注：当一个接口中存在多个抽象方法时，如果使用lambda表达式，并不能智能匹配对应的抽象方法，因此引入了函数式接口的概念</p>
<h2 id="二-函数式接口"><a class="markdownIt-Anchor" href="#二-函数式接口"></a> 二 <strong>函数式接口</strong></h2>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>MD插入图片</title>
    <url>/2020/03/03/MarkDown/</url>
    <content><![CDATA[<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片下缀</span>](<span class="link">xxx名字/图片名字.格式</span>)</span><br></pre></td></tr></table></figure>
<p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code></p>
<p>xxx指的是要插入的MD的文件名的文件夹</p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>常见操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注入</title>
    <url>/2020/03/02/Spring%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.ioc.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="error"><a class="markdownIt-Anchor" href="#error"></a> Error:</h4>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">" "</span> <span class="built_in">class</span>=<span class="string">" "</span>/&gt;    || &lt;bean <span class="built_in">id</span>=<span class="string">" "</span> <span class="built_in">class</span>=<span class="string">""</span>&gt; &lt;<span class="keyword">property</span>&gt; &lt;/<span class="keyword">property</span>&gt;&lt;/bean&gt;均可</span><br></pre></td></tr></table></figure>
<h5 id="1-依赖注入"><a class="markdownIt-Anchor" href="#1-依赖注入"></a> 1 依赖注入</h5>
<p>依赖注入的作用是在使用 Spring 框架创建对象时,动态地将其所依赖的对象注入 Bean 组件中, 其实现方式通常有两种, 一种是属性 setter 方法注入, 另一种是构造方法注入.</p>
<h6 id="setter方法注入"><a class="markdownIt-Anchor" href="#setter方法注入"></a> setter方法注入</h6>
<blockquote>
<ul>
<li>Spring 容器使用 setter 方法注入被依赖的实例. 通过调用无参构造器或无参静态工厂方法实例化Bean 后, 调用该Bean 的setter方法, 即可实现基于setter方法依赖的注入</li>
</ul>
</blockquote>
<h6 id="构造方法注入"><a class="markdownIt-Anchor" href="#构造方法注入"></a> 构造方法注入</h6>
<blockquote>
<ul>
<li>指Spring 容器使用构造方法注入被依赖的实例</li>
</ul>
</blockquote>
<a id="more"></a>
<p>本章代码小结:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line">package com.itheima.ioc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">            ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">            UserDao userDao=(UserDao) applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">            userDao.say();</span><br><span class="line">            UserService userService=(UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">            userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDaoImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Userdao say hellpo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span>  <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.say();</span><br><span class="line">        System.out.println(<span class="string">"uSERdao server say heellpo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
      <tags>
        <tag>犯过的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/03/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>树（Tree）是n（n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：<br>
1）有且仅有一个特定的称为根（Root）的结点；<br>
2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p>
<p>此外，树的定义还需要强调以下两点：<br>
1）n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。<br>
2）m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</p>
<p>二叉树性质<br>
1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）<br>
2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）<br>
3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>
4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>
5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p>
<p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br>
(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；<br>
(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</p>
<a id="more"></a>
<p>树的基础结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">​	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">​	Typedef val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> va)&#123;val=va;left==<span class="literal">nullptr</span>;right==<span class="literal">nullptr</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树的创建"><a class="markdownIt-Anchor" href="#二叉树的创建"></a> 二叉树的创建</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(TreeNode* t,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ve.<span class="built_in">size</span>()==i)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    t=<span class="keyword">new</span> TreeNode(ve[i++]);</span><br><span class="line">    createTree(t-&gt;left,ve,i);</span><br><span class="line">    createTree(t-&gt;right,ve,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树的几种遍历方式"><a class="markdownIt-Anchor" href="#二叉树的几种遍历方式"></a> <strong>二叉树的几种遍历方式</strong></h5>
<table>
<thead>
<tr>
<th>前序遍历</th>
<th>根左右</th>
<th>dfs</th>
</tr>
</thead>
<tbody>
<tr>
<td>中序遍历</td>
<td>左根右</td>
<td>dfs</td>
</tr>
<tr>
<td>后序遍历</td>
<td>右根左</td>
<td>dfs</td>
</tr>
<tr>
<td>层序遍历</td>
<td>一层一层遍历</td>
<td>bfs</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==nullprt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PreOrderTraverse(t-&gt;left);</span><br><span class="line">    PreOrderTraverse(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(t-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraverse(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(t-&gt;left);</span><br><span class="line">    PostOrderTraverse(t-&gt;right);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br></pre></td></tr></table></figure>
<p>递归算法时间复杂度往往太高.</p>
<p>使用非递归算法,先序中序后序,则需要借助栈来实现,层序遍历需借助队列来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归先序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PreOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ve;</span><br><span class="line">    Stack&lt;TreeNode*&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            ve.push_back(t-&gt;val);</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ve;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">InOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            ve.push_back(t-&gt;val);</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归后序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">LastOrder</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* temp;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t)&#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            temp=s.pop();</span><br><span class="line">            <span class="keyword">if</span>((t-&gt;right==nullprt)||(t-&gt;right-&gt;val==ve.back()))&#123;</span><br><span class="line">              	ve.push_back(t-&gt;val)</span><br><span class="line">                temp=nullprt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.push(t);</span><br><span class="line">                t=t-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">SeqTraverse</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()||t)&#123;</span><br><span class="line">        TreeNode* w=q.pop();</span><br><span class="line">        ve.push_back(w-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(w-&gt;left)</span><br><span class="line">            q.push(w-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(w-&gt;right)</span><br><span class="line">            q.push(w-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断二叉树的深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">max</span>(<span class="number">1</span>+TreeDepth(pRoot&gt;left),<span class="number">1</span>+TreeDepth(pRoot-&gt;right));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/2020/03/01/categories/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于面试的问题</title>
    <url>/2020/03/01/C/</url>
    <content><![CDATA[<h1 id="以后要准备充分再面试"><a class="markdownIt-Anchor" href="#以后要准备充分再面试"></a> 以后要准备充分再面试</h1>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面试1</title>
    <url>/2020/03/01/JAVA%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<h4 id="java内存机制"><a class="markdownIt-Anchor" href="#java内存机制"></a> JAVA内存机制</h4>
<blockquote>
<ul>
<li>私有内存区:伴随线程产生而产生 , 一旦线程终止, 私有内存区也会自动清除</li>
<li></li>
</ul>
</blockquote>
<p>​</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA垃圾回收GC</title>
    <url>/2020/03/01/JAVA/</url>
    <content><![CDATA[<p><img src="/.com/2020/03//JAVA%E5%86%85%E5%AD%98.jpg" alt></p>
<h4 id="java内存机制"><a class="markdownIt-Anchor" href="#java内存机制"></a> JAVA内存机制</h4>
<blockquote>
<ul>
<li>私有内存区:伴随线程产生而产生 , 一旦线程终止, 私有内存区也会自动清除</li>
<li>程序计数器: 指示当前程序执行到了哪一行,执行Java方法时记录正在执行的虚拟机字节码指令地址; 执行本地方法时, 计数器值为NULL</li>
<li>虚拟机栈: 用于执行Java方法, 栈存储局部变量表, 操作数栈, 动态链接, 方法返回地址和一些额外的附加信息. 程序执行时入栈; 执行完成后栈帧出栈.</li>
<li>Java堆: Java虚拟机管理的内存最大的 一块, 所有线程共享, 几乎所有的对象实例和数组都在这里分配内存. <strong>GC主要就是在Java堆里进行</strong>.堆内存又分为: 新生代(新生代又分为 Eden80%, Survivor20%) 和老生代(Old) , 并且一般新生代的空间比老年代大.</li>
<li>方法区: 只有一个方法区共享. 实际也是堆,只是用于存储类, 常量相关的信息, 来存放程序中永远不变或唯一的内容(类信息[Class对象], 静态变量, 字符串常量等). 但是已经被最新的JVM取消了,现在,被加载的类作为元数据加载到底层操作系统的本地内存区.</li>
</ul>
</blockquote>
<h4 id="垃圾回收机制"><a class="markdownIt-Anchor" href="#垃圾回收机制"></a> 垃圾回收机制</h4>
<h6 id="gc的主要任务"><a class="markdownIt-Anchor" href="#gc的主要任务"></a> Gc的主要任务:</h6>
<ol>
<li>分配内存</li>
<li>确保被引用对象的内存不被错误的回收</li>
<li>回收不再被引用的对象的内存空间</li>
</ol>
<h6 id="垃圾回收机制的主要解决问题"><a class="markdownIt-Anchor" href="#垃圾回收机制的主要解决问题"></a> 垃圾回收机制的主要解决问题</h6>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<a id="more"></a>
<p><strong>针对问题1: 垃圾收集器会对堆进行回收前, 去确定对象中哪些是&quot;存活&quot; , 哪些是&quot; 死亡&quot; (不能再被任何途径使用的对象)</strong></p>
<p>判断:</p>
<ol>
<li>
<p>引用计数法</p>
<p>每当一个地方引用时, 计数器+1 ; 引用失效时, 计数器 -1; 计数值 =0  不可能再被引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例：</span></span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line">        test1.obj = test2;</span><br><span class="line">        test2.obj = test1;</span><br><span class="line">        <span class="comment">//test1 ，test12能否被回收？</span></span><br><span class="line">        System.gc();</span><br></pre></td></tr></table></figure>
<p>查看运行结果，会发现并没有因为两个对象互相引用就没有回收，因此引用计数算法很难解决<strong>对象之间相互矛盾循环引用</strong>的问题。</p>
</li>
<li>
<p>可达性分析算法:</p>
<p>向图,树图, 把一系列&quot;GC Roots&quot; 作为起始点, 从节点向下搜索, 路径成为引用链, 当一个对象到 GC Roots没有任何引用链相连, 即不可达时, 则证明此对象是不可用的.</p>
<p>**Eg:**一颗树有很多丫枝，其中一个分支断了，跟树上没有任何联系，那就说明这个分支没有用了，就可以当垃圾回收去烧了。</p>
<p>**Tips:**在Java中可作为GCRoots的对象:</p>
<ol>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象;</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象.</li>
</ol>
</li>
</ol>
<h6 id><a class="markdownIt-Anchor" href="#"></a> </h6>
<p><strong>问题2   什么时候回收?</strong></p>
<p>即使是被判断不可达的对象, 也要再进行筛选, 当对象没有覆盖finalize()方法, 或者finaize()方法已经被虚拟机调用过, 则没有必要执行;</p>
<p>如果有必要执行:</p>
<ol>
<li>放置在F-Queue队列中</li>
<li>Finalizer线程执行</li>
</ol>
<p>**Tips:**对象可以在被GC时可以自我拯救（this），机会只有一次，因为任何一个对象的finalize() 方法都只会被系统自动调用一次。并不建议使用，应该避免。使用try_finaly或者其他方式。</p>
<p><strong>问题3  如何回收</strong></p>
<ol>
<li>
<p>标记.清除算法</p>
<p>两个阶段: 标记, 清除;</p>
<p>不足: 效率问题,空间问题(会产生大量不连续的内存碎片)</p>
</li>
<li>
<p>复制算法(新生代 )</p>
<p>将可用内存按容量分为大小相等的两块, 每次都只使用其中一块;</p>
<p>不足: 将内存缩小为了原来的一半</p>
</li>
<li>
<p>标记. 整理算法  (Old)</p>
<p>标记,清除(让存活的对象都像一端移动)</p>
</li>
</ol>
<p>垃圾回收的流程:</p>
<ol>
<li>新建的对象,大部分存储在Eden中</li>
<li>当Eden内存不够, 就进行Minor GC释放掉不活跃的对象存放到另一个Survivor中,(如Survivor1).</li>
<li>当Eden区再次满了, 将Survivor1中不能清空的内容放到Survivor2中,同时将Eden区.中的不能清空的对象, 复制到Survivor1, 同时清空Eden区</li>
<li>重复多次(默认15次) :Survivor中没有被清理的对象会复制到老年区(Old)</li>
<li>当Old达到一定比例就会触发Major GC释放老年代</li>
<li>当Old区满了, 则触发一个一次完整的垃圾回收(Full GC)</li>
<li>如果内存还是不够, JVM会抛出内存不足, 发生oom, 内存泄漏</li>
</ol>
<p><strong>默认比例:</strong></p>
<ol>
<li>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 );</li>
<li>新生代 Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )</li>
</ol>
<p><strong>补充1:</strong> 分代垃圾回收</p>
<blockquote>
<ul>
<li>Minor用于清理新生代(Eden)区域, Eden区满了就会触发一次Minor GC, 清理无用对象, 将有用对象复制到&quot;Survivor1&quot;, “Survivor2” 区中(这两个区，大小空间相同，同一时刻Survivor1和Survivor2只有一个在用一个为空).</li>
<li>Major GC: 用于清理老年代区域</li>
<li>Full GC: 用于清理新生代, 老年代区域, 成本较高, 会对系统性能产生影响.</li>
</ul>
</blockquote>
<p><strong>补充2:</strong></p>
<p>在对JVM调优的过程, 很大一部分工作就是对于Full GC 调节. 根据上述GC过程, 我们可以发现老年代被写满, System.gc()被现实调用, 上一次GC之后Heap的各域分配策略动态变化都可能导致Full GC.</p>
<p>开发中容易造成内存泄漏的操作:</p>
<blockquote>
<ul>
<li>创建大量无用的对象:比如需要大量连接字符串时,使用String而不是StringBulider/StringBuffer/线程池.</li>
<li>静态集合类的使用: HashMap, Vector , List</li>
<li>各种连接对象未及时释放关闭</li>
<li>监听器的使用</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
